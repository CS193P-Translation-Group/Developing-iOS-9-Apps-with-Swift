1
00:00:00,001 --> 00:00:03,802
[MUSIC]

2
00:00:03,804 --> 00:00:08,040
Standford University. >> All right,
斯坦福大学

3
00:00:08,042 --> 00:00:13,746
welcome then to lecture number eight. I think it's eight,
欢迎参加第八讲。好像是第八讲。

4
00:00:13,748 --> 00:00:18,083
yes, of CS193P Spring of 2016. So today, we start off
是的，2016 春季 CS193P 课程。今天，我们将

5
00:00:18,085 --> 00:00:21,020
by continuing that demo that we were doing last time.
继续完成上一次的 demo

6
00:00:21,022 --> 00:00:24,423
Remember we had the demo, Cassini demo with the, scroll
今天用到之前 scroll view 写的 Cassini

7
00:00:24,425 --> 00:00:27,693
view in there. And so I'm gonna make it more powerful,
让它功能更加强大.

8
00:00:27,695 --> 00:00:30,262
we're gonna get multiple MVCs going in there.
我们将会用到多个 MVC 的结构.

9
00:00:30,264 --> 00:00:34,533
We'll start doing some zooming in the scroll view.
会用到 scroll view 的缩放属性.

10
00:00:34,535 --> 00:00:37,703
Depending on how the time goes I might actually show you some
如果有时间，我会通过实际案例来

11
00:00:37,705 --> 00:00:40,406
things that couple of you have asked about on Piazza.
解答有些同学对 Piazza 项目的疑问.

12
00:00:40,408 --> 00:00:44,009
Like, how to when I launch my calculator app can I have it
例如，在启动我的计算器 app 的时候，

13
00:00:44,011 --> 00:00:46,311
not launch and show a blank graph, right,
因为没有启动图而显示空白的情况.

14
00:00:46,313 --> 00:00:49,314
how can I have it launch and show the calculator for
怎样才能在在第一次启动计算器时，

15
00:00:49,316 --> 00:00:52,651
the very first time, okay, those kinds of things.
显示启动页等，诸如此类的问题.

16
00:00:52,653 --> 00:00:53,652
So we'll see how the time goes and
最后，我们会根据时间安排

17
00:00:53,654 --> 00:00:56,121
decide on the fly whether to do that stuff.
来决定是否要解答这些.

18
00:00:56,123 --> 00:00:57,623
Then we're gonna dive back into the slides.
让我们回到幻灯片上.

19
00:00:57,625 --> 00:00:59,358
I'm gonna talk about multi-threading, okay?
我之后还会讲到多线程.

20
00:00:59,360 --> 00:01:04,029
Very, very important thing in iOS is how to multithread
在 iOS 上，多线程的处理是非常非常重要的内容.

21
00:01:04,031 --> 00:01:06,799
your execution. And then I'll go back to the demo, and
然后我们会回到 Cassini demo,

22
00:01:06,801 --> 00:01:10,436
we'll multithread this Cassini thing we're working on, okay?
为它加上多线程支持.

23
00:01:10,438 --> 00:01:12,104
And then time permitting at the end I'll go back to
在时间允许的情况下, 最后还会回到幻灯片

24
00:01:12,106 --> 00:01:14,673
the slides and I'm gonna talk about text fields. And
讲一下 text field. 然后

25
00:01:14,675 --> 00:01:19,511
then, next week we have table views, databases, etc. And
下周会讲 table view，database 等内容.

26
00:01:19,513 --> 00:01:21,947
again, remember, no assignment going out today.
今天不会布置作业.

27
00:01:21,949 --> 00:01:24,283
The assignment is gonna be a table view based thing, so
作业是基于 table view 的,

28
00:01:24,285 --> 00:01:27,986
it will go out after Monday's lecture, all right? So,
所以我们会在下周一课程之后再布置, 没问题吧.

29
00:01:27,988 --> 00:01:30,589
let's dive back into this Cassini demo. Okay,
那么, 让我们回到 Cassini demo.

30
00:01:30,591 --> 00:01:36,762
we'll start off just exactly where we left off before. So
接着上一次的内容继续完善.

31
00:01:36,764 --> 00:01:41,100
we'll go to Xcode here. So I'm just gonna open Cassini,
启动 Xcode, 打开 Cassini

32
00:01:41,102 --> 00:01:42,868
here it is. I'm just gonna run it real quick just
我先来带大家快速过一遍

33
00:01:42,870 --> 00:01:47,139
to remind you where we were for those with short memories.
回忆下之前的内容.

34
00:01:47,141 --> 00:01:53,812
Even though it's only two days ago. All right,
虽然是两天前才讲的.

35
00:01:53,814 --> 00:01:56,915
here it is. So we've got, our image view, right?
好的, 我们有一个 image view.

36
00:01:56,917 --> 00:02:00,285
We have an ImageView and it's inside a UIScrollView, and so
这个 ImageView 嵌套在 UIScrollView 中,

37
00:02:00,287 --> 00:02:03,922
we're able to scroll around, okay, just by panning with our
所以我们可以进行滚动, 用手指滑动就行

38
00:02:03,924 --> 00:02:06,291
finger. My mouse is like a finger there, so
这光标就是手指

39
00:02:06,293 --> 00:02:10,262
I'm just panning around, and that's all we can do, okay?
目前就只能随意滑动

40
00:02:10,264 --> 00:02:11,997
But we've created this nice UI, or
但是我们这个漂亮的界面

41
00:02:11,999 --> 00:02:15,734
this nice ImageViewController, which is an MVC that lets you
或者说, 漂亮的 ImageViewController 所用的 MVC 模式,

42
00:02:15,736 --> 00:02:19,371
take any image and put it on screen inside the scroll view,
能任意将图片加入到 scroll view 中, 并显示出来

43
00:02:19,373 --> 00:02:23,108
that's kind of a nice reusable, reusable MVC, right?
有很好的重用性, 重用 MVC, 对吧

44
00:02:23,110 --> 00:02:26,378
So now we're going to make this a multi-MVC app, okay,
接下来, 我们会做一个多 MVC 的 app

45
00:02:26,380 --> 00:02:28,213
and I'm gonna reuse this ImageViewController
重用的 ImageViewController

46
00:02:28,215 --> 00:02:31,450
as one of the MVCs. So let's go right to our storyboard,
也是其中之一. 让我们打开 storyboard.

47
00:02:31,452 --> 00:02:32,117
see what this is gonna look like.
来看看里面都有什么内容

48
00:02:32,119 --> 00:02:34,419
This is where the Cassini part of this whole thing is gonna
Cassini 所展示的内容都从这里得到.

49
00:02:34,421 --> 00:02:37,589
come in. All right, I'm gonna create a new View Controller,
现在, 我准备创建一个新的 View Controller

50
00:02:37,591 --> 00:02:39,224
just gonna drag it out right here. Again,
将它拖到这里就可以了

51
00:02:39,226 --> 00:02:41,693
I'm gonna go fairly quickly, cuz I've done this all before,
之前我们已经做过了, 所以这一步操作有点快

52
00:02:41,695 --> 00:02:44,630
so this is almost like a review, for you here.
更像是在帮大家复习

53
00:02:44,632 --> 00:02:45,397
So, I have this controller.
好, controller 创建好了

54
00:02:45,399 --> 00:02:48,700
It needs to have a custom subclass of UIViewController
因为需要自定义 UIViewController

55
00:02:48,702 --> 00:02:51,904
so I'm going to create such a thing. Go here to New File,
所以要做接下来的这些操作. 创建一个新文件

56
00:02:51,906 --> 00:02:55,274
it's iOS source, it's a Cocoa Touch Class. Cuz it's
选择 iOS source, Cocoa Touch Class, 因为

57
00:02:55,276 --> 00:02:58,210
a subclass of an iOS class, which is a UIViewController in
要子类化的类属于 iOS, 这里是 UIViewController

58
00:02:58,212 --> 00:03:01,647
this case. I'm going to call this CassiniViewController,
类名就叫 CassiniViewController 吧

59
00:03:01,649 --> 00:03:04,149
cuz it's gonna let us look at some Cassini images.
这个类会展示更多 Cassini 的图片

60
00:03:04,151 --> 00:03:08,587
That's what our app is gonna do. But just in the same place
也是这个 app 的需求. 存放路径和之前一样

61
00:03:08,589 --> 00:03:11,523
as always here is our CassiniViewController,
CassiniViewController 创建好了

62
00:03:11,525 --> 00:03:15,327
I'm gonna remove the view controller lifecycle methods
暂时先删除模板给出的 view controller

63
00:03:15,329 --> 00:03:18,630
that it gives me right here just for now anyway.
生命周期方法

64
00:03:18,632 --> 00:03:22,067
And I'm actually gonna uncomment this prepareForSegue
然后打开 prepareForSegue 的注释

65
00:03:22,069 --> 00:03:24,002
because my CassiniViewController is
因为 CassiniViewController 会

66
00:03:24,004 --> 00:03:27,005
definitely going to be doing, some segueing.
用到这个方法, 一些 segue

67
00:03:27,007 --> 00:03:29,341
So let's now go back to our storyboard,
现在让我们回到 storyboard

68
00:03:29,343 --> 00:03:32,744
now that we have this ImageViewController class, and
我们已经有了 ImageViewController

69
00:03:32,746 --> 00:03:36,315
I'm gonna change the class of this controller right here
再通过 identity inspector, 将这个

70
00:03:36,317 --> 00:03:40,452
with the identity inspector, to be a CassiniViewController,
controller 改为 CassiniViewController

71
00:03:40,454 --> 00:03:45,724
okay. Everybody got that? I'm going to put this whole
好的, 都能跟上吧? 接下来, 我会将整个

72
00:03:45,726 --> 00:03:49,494
MVC structure into that split view with navigation that's
MVC 结构装到 split view 中

73
00:03:49,496 --> 00:03:52,331
over in there, the thing that will work in both iPad and
这样就能同时用 iPad 和

74
00:03:52,333 --> 00:03:55,300
iPhone, exact same thing we did for,
iPhone 上, 这种处理方式我们在

75
00:03:55,302 --> 00:03:57,869
the emotions view controller. So, let's do that.
emotions view controller 上也做过. 下面来实现吧.

76
00:03:57,871 --> 00:04:00,939
I'm going to start by dragging out the split view controller,
接下来需要拖一个 split view controller

77
00:04:00,941 --> 00:04:02,007
I'm gonna zoom way out here.
先缩小画板

78
00:04:02,009 --> 00:04:04,810
Let's go get a Split View Controller, here it is. I'll
然后找到 Split View Controller

79
00:04:04,812 --> 00:04:09,781
drag it out. I'll get rid of these extra things that came
拖拽出来. 删掉除了

80
00:04:09,783 --> 00:04:12,551
along here with the Split View Controller because I already
Split View Controller 的其他内容, 因为我们已经

81
00:04:12,553 --> 00:04:15,153
have my master and detail right here. The Cassini's
有自己的 master 和 detail 了. Cassini 是

82
00:04:15,155 --> 00:04:17,956
gonna be my master and this ImageViewController's gonna be
master, ImageViewController 是 detail.

83
00:04:17,958 --> 00:04:21,260
my detail right there. So I'm just gonna Control drag, hook
按住 Control 并拖拽到 master

84
00:04:21,262 --> 00:04:25,197
up my master. And a Control drag, hook up my detail.
然后按住 Control 并拖拽到 detail

85
00:04:25,199 --> 00:04:28,400
I'm also gonna take my little entry arrow and make it so
接下来, 将入口箭头移动到

86
00:04:28,402 --> 00:04:31,136
that it enters on the Split View Controller. Right,
Split View Controller

87
00:04:31,138 --> 00:04:32,738
instead of entering on my Image View Controller,
Image View Controller 不再是入口

88
00:04:32,740 --> 00:04:37,376
obviously. And, I want this to work on both iPhone and iPad,
我想要在 iPhone 和 iPad 上使用

89
00:04:37,378 --> 00:04:41,013
so I'm gonna take my master and put it embedded inside
所以, 我准备将 master 嵌入到 

90
00:04:41,015 --> 00:04:45,917
of a navigation controller, okay? And maybe I can even go
navigation controller 中, 然后我能在这

91
00:04:45,919 --> 00:04:50,589
in here and put a nice title here, right here. Cassini,
给它加上 title. Cassini.

92
00:04:50,591 --> 00:04:54,626
okay? All right now, what is this UI going to do?
跟上了吗? 最终, 这个界面到底有什么作用?

93
00:04:54,628 --> 00:04:57,029
What's it going to look like? How's it gonna function?
长什么样呢? 怎样触发一些功能?

94
00:04:57,031 --> 00:04:59,598
Well, I'm just gonna have three buttons here.
好的, 我会在这里放 3 个按钮

95
00:04:59,600 --> 00:05:01,500
Similar to how I had in emotions view controller.
和之前的 emotions view controller 很像

96
00:05:01,502 --> 00:05:04,102
In a demo I can only do, I can't do a nice complicated
在 demo 中也只能这样了, 不能像计算器

97
00:05:04,104 --> 00:05:07,172
MVC like a calculator and then another complicated one like
一样有复杂的 MVC 结构, 也不能像

98
00:05:07,174 --> 00:05:09,808
a graph view. I have to do a simple one. So I'm gonna do
graph view 那样复杂. 只能做个简单的界面了. 所以我也只好

99
00:05:09,810 --> 00:05:11,877
a simple one here. Where I'm gonna put three buttons and
这样了. 之所以我要放三个按钮,

100
00:05:11,879 --> 00:05:15,180
those three buttons are just going to cause three different
是因为要展示三张

101
00:05:15,182 --> 00:05:20,285
images from NASA, okay, about Cassini which is a little
NASA 的图片. 至于 Cassini, 它是被

102
00:05:20,287 --> 00:05:22,988
thing sent out into space to take pictures. I'm gonna put
发送到太空来拍摄图片的. 我会把

103
00:05:22,990 --> 00:05:25,223
those three buttons here and then were just gonna segue,
三个按钮放到这, 然后我们处理 segue,

104
00:05:25,225 --> 00:05:27,826
as we know how to do, down to here,
大家应该知道怎么做. 将 ImageViewController

105
00:05:27,828 --> 00:05:29,194
which is gonna be our ImageViewController,
放到下面来

106
00:05:29,196 --> 00:05:30,662
all right. So the Image View Controller's just gonna show
Image View Controller 会用来显示图片

107
00:05:30,664 --> 00:05:33,065
the image, and we already know that the Image View Controller
我们已经知道展示图片的 Image View Controller 是一个

108
00:05:33,067 --> 00:05:35,901
is a nice, little, reasonable MVC that shows an image.
优雅的, 小巧的, 合理的 MVC 结构.

109
00:05:35,903 --> 00:05:37,836
So it's perfect, exactly what I want. So
如此完美, 正是我们想要的

110
00:05:37,838 --> 00:05:39,871
I'm gonna go down here and get the buttons. So it's this
向下滚动, 找到按钮.

111
00:05:39,873 --> 00:05:44,343
button right here. Let's go ahead and make it bigger,
将按钮放在这. 继续, 把它放大点,

112
00:05:44,345 --> 00:05:48,580
I'll say 40 point would be a pretty good size here.
设置为 40 点看起来比较好

113
00:05:48,582 --> 00:05:52,417
And, make three of them, copy, paste so
然后创建三个这样按钮, 复制, 粘贴

114
00:05:52,419 --> 00:05:56,154
I get that. Okay, one of them is gonna be called Earth,
好了, 一个叫做 Earth

115
00:05:56,156 --> 00:05:59,291
another one is gonna be called Cassini.
一个叫做 Cassini.

116
00:05:59,293 --> 00:06:02,194
And another one is gonna be called Saturn, okay?
剩下的一个叫 Saturn, 好了吗?

117
00:06:02,196 --> 00:06:04,262
And then I'm just gonna take these three things.
然后, 将这三个按钮

118
00:06:04,264 --> 00:06:06,031
Of course it put them in a stack view.
放到 stack view 中

119
00:06:06,033 --> 00:06:11,903
Okay, we'll go ahead and have the stack view be fill.
ok, 将 stack view 对齐方式设置为 fill.

120
00:06:11,905 --> 00:06:13,338
And we'll also do again fill equally.
然后将分布设置为 fill equally.

121
00:06:13,340 --> 00:06:15,474
It doesn't really matter because they're all identical,
这些都无关紧要, 它们都是相同的

122
00:06:15,476 --> 00:06:17,909
they're all buttons. We'll put a little spacing in there,
都是按钮. 然后给它们加一些间隙

123
00:06:17,911 --> 00:06:21,179
maybe. 20 points something like that. Then I'm gonna drag
20 点之类的. 接下来将它拖到

124
00:06:21,181 --> 00:06:24,082
this into the middle use my blue lines right there so that
视图中间, 有蓝色对齐线这里

125
00:06:24,084 --> 00:06:27,152
I can go here and say Reset to suggested constraints.
点击这里, 选择 Reset to suggested constraints (重置为建议约束).

126
00:06:27,154 --> 00:06:29,588
And then I'm gonna go over to my size inspector and
接着看到 size inspector

127
00:06:29,590 --> 00:06:32,224
double check that it did the kind of constraints I want.
再次确认约束是否正确添加

128
00:06:32,226 --> 00:06:35,227
Which that looks good to me it's gonna align these things
看来这些约束能正确将

129
00:06:35,229 --> 00:06:39,030
in the center, okay? So, here's our UI right here.
视图居中, 好了吗? 这就是我们的 UI 了.

130
00:06:39,032 --> 00:06:43,802
Now, all we need to do is have these three things segue down
现在, 就只需要将这三个按钮的事件和下面

131
00:06:43,804 --> 00:06:47,472
to here to fill these images. Now, I'll show you where these
这个关联, 来显示图片了. 之后, 我会展示这些

132
00:06:47,474 --> 00:06:49,841
images come from in a minute here, but let's just create
图片从哪来, 现在先来创建 segue.

133
00:06:49,843 --> 00:06:52,110
the segue. Now, I'm gonna do something a little different
这次我们处理 segue 的方式和之前不一样.

134
00:06:52,112 --> 00:06:55,847
with this segue. In our last one I, each segue had
之前, 每个 segue 都有

135
00:06:55,849 --> 00:06:57,816
its own identifier that was different, and
自己的 identifier, 每一个都不同

136
00:06:57,818 --> 00:07:00,619
it was the identifier that let us know which emotion to
这些 identifier 使我们知道应该

137
00:07:00,621 --> 00:07:03,488
show in the emotions one. Here I'm gonna have them all have
显示哪个表情. 这一次, 它们只有

138
00:07:03,490 --> 00:07:06,591
the same identifier, and I'm gonna use the title of
一个相同的 identifier, 我将使用按钮的 title

139
00:07:06,593 --> 00:07:09,628
the button to decide which image, okay? So it's kind of
来决定显示的图片. 所以, 

140
00:07:09,630 --> 00:07:11,897
a cross between what we did in the calculator and
这和我们之前做计算器,

141
00:07:11,899 --> 00:07:14,666
what we did in emotions, all right? So, let's go ahead and
做表情的处理不一样.

142
00:07:14,668 --> 00:07:17,969
create these things. So, I'm gonna, Control drag, okay,
下面我们来创建 segue 吧. 按钮 Contorl 并拖拽,

143
00:07:17,971 --> 00:07:21,540
from Saturn down to here. This is in a split view, right,
从 Saturn 到这里. 他们都在 split view 中.

144
00:07:21,542 --> 00:07:22,374
so I'm gonna do Show Detail, right?
选择 Show Detail.

145
00:07:22,376 --> 00:07:25,143
That's the kind of segue I want, not show. The same thing
这才是我想要的 segue, 而不是 Show.

146
00:07:25,145 --> 00:07:29,514
with Cassini right here, Show Detail. And then up here to
Cassini 也是同样, ShowDetail. 接着是

147
00:07:29,516 --> 00:07:34,486
Earth, Show Detail. Whoops, not Present Modally, undo,
Earch, Show Detail. 噢, 不是 Present Modally, 撤销,

148
00:07:34,488 --> 00:07:38,990
let's try that again. Show Detail. Okay, so
重新来一次, Show Detail.

149
00:07:38,992 --> 00:07:41,092
we've got these three things here. Let's go ahead and
这三个就关联好了. 然后来检查下.

150
00:07:41,094 --> 00:07:43,662
inspect them. I'm gonna put an identifier on them but
我准备给它们设置 identifier, 但

151
00:07:43,664 --> 00:07:45,163
they're all gonna have the same identifier.
它们的 identifier 都相同.

152
00:07:45,165 --> 00:07:48,266
And what that means is when prepareForSegue gets called,
那么, 这在调用 prepareForSegue 时意味着什么呢

153
00:07:48,268 --> 00:07:51,169
it's gonna be called, and the same thing is gonna happen for
调用时, 他们所触发的事件都是相同的.

154
00:07:51,171 --> 00:07:53,505
each one. Again I'm gonna look at the sender in
不过, 可以通过

155
00:07:53,507 --> 00:07:54,706
prepareForSegue to know which button,
prepareForSegue 的 sender 来区别按钮,

156
00:07:54,708 --> 00:07:57,175
but we're gonna use the same code. So I'm gonna call this
但是它们的代码是共用的. 所以, 就命名为

157
00:07:57,177 --> 00:08:00,345
Show Image, cuz that's what it does, okay, when you click On
Show Image 吧, 见名知意.

158
00:08:00,347 --> 00:08:03,381
here to segue, it segues to this image view controller and
点击 Segue, 跳转到 image view controller

159
00:08:03,383 --> 00:08:06,585
shows an image. Okay, so let's make sure all three of
显示图片. 确保三个按钮都

160
00:08:06,587 --> 00:08:10,755
them are doing that. Okay, so everybody cool with this?
设置好. 好了, 大家对这一步有疑问吗?

161
00:08:10,757 --> 00:08:14,092
This is all just review, I haven't done anything new, yet
以上是对之前的回顾，还没添加新的知识点

162
00:08:14,094 --> 00:08:17,829
here. K, now of course we know if we want these
如果想要这些 segue 生效

163
00:08:17,831 --> 00:08:21,366
little segues here to work, we need to prepare them, so
还需要准备 segue

164
00:08:21,368 --> 00:08:25,003
let's go back to our Cassini View Controller right here and
接下来回到 Cassini View Controller，

165
00:08:25,005 --> 00:08:27,973
do our prepare for segue. I'm gonna show you something
准备 segue. 接下来我会演示如何

166
00:08:27,975 --> 00:08:31,109
that's kind of nice to do from a clean coding mechanism,
在用纯代码来实现

167
00:08:31,111 --> 00:08:35,747
which is I like to create a private struct here to
我比较喜欢创建一个私有 struct

168
00:08:35,749 --> 00:08:38,750
store my constants that are strings in the storyboard.
来存放 storyboard 中 string 类型的常量

169
00:08:38,752 --> 00:08:42,754
So I usually call this thing storyboard okay? And then I
所以命名为 storyboard

170
00:08:42,756 --> 00:08:47,225
just put these static lets inside. So the ShowImageSegue
然后将这些静态常量放到 struct 中. ShowImageSegue

171
00:08:47,227 --> 00:08:51,296
= "Show Image". So that this string, and basically any
= "Show Image". 就是这样. 在

172
00:08:51,298 --> 00:08:55,400
string that I put anywhere in my story board, like in these,
storyboard 中的其他 string 也都和这个类似，

173
00:08:55,402 --> 00:08:58,236
when I inspect these things down here like this string.
比如看到的这个下面这个 string

174
00:08:58,238 --> 00:09:02,440
Okay? That's all collected here into this nice struct.
将这些都添加到 struct 中

175
00:09:02,442 --> 00:09:03,208
Okay? So
到此，

176
00:09:03,210 --> 00:09:05,644
we already know that this is what we do to do constants,
我们已经知道怎样处理这些常量了

177
00:09:05,646 --> 00:09:08,113
okay? I'm just calling this group of constants storyboard.
我暂且把这个集合称为 storyboard 常量集吧

178
00:09:08,115 --> 00:09:10,882
They're my storyboard constants, all right?
这就是我的 storyboard 常量集了

179
00:09:10,884 --> 00:09:14,252
All right, so let's do prepare for segue right here.
然后在这里准备 segue

180
00:09:14,254 --> 00:09:15,820
What do we need to do in prepare for segue?
我们需要在 prepareForsSegue 中做哪些处理？

181
00:09:15,822 --> 00:09:19,324
Well first of all, we probably want to make sure that this is
首先，我们要确保 segue 是

182
00:09:19,326 --> 00:09:23,194
the show image segue, so I'm going to say if the segue's
show image segue，所以先进行判断

183
00:09:23,196 --> 00:09:28,366
identifier = the storyboard.ShowImageSegue.
segue 的 identifier 是否等于 Storyboard.ShowImageSegue

184
00:09:28,368 --> 00:09:31,469
Okay? Then we know this is what we're preparing for.
这一步是保证我们处理的是正确的 segue

185
00:09:31,471 --> 00:09:34,539
And remember,
记住，在一个复杂的 app 中，可能会有很多不同的

186
00:09:34,541 --> 00:09:37,309
of segues, like we have in emotions actually, with
segue，就像我们有不同的情绪一样，它们有

187
00:09:37,311 --> 00:09:39,911
different identifiers going off. So that's why we almost
不同的标识. 所以我们

188
00:09:39,913 --> 00:09:43,114
always check the identifier first just to make sure
通常使用 identifier 来确保

189
00:09:43,116 --> 00:09:44,583
that we are doing the right thing, and
处理方式是对的

190
00:09:44,585 --> 00:09:48,153
usually we'll try and spell identifier properly. Okay.
当然，还需要正确的拼写 identifier

191
00:09:48,155 --> 00:09:52,157
So now, we know this is the right segue. We need to get
现在，我们知道这里就是想要的 segue 了. 还需要

192
00:09:52,159 --> 00:09:55,293
the MVC that we're segueing to so we can prepare it.
有一个 MVC 结构来准备 segue

193
00:09:55,295 --> 00:09:57,662
So we know that's supposed to be an Image View Controller so
假设需要的是 Image View Controller

194
00:09:57,664 --> 00:10:00,999
I'm going to say if I can let IVC, short for
所以定义一个叫做 ivc 的常量

195
00:10:01,001 --> 00:10:01,900
Image View Controller,
ImageViewController 的简写

196
00:10:01,902 --> 00:10:07,772
equal the segue's destination view controller as
等于 segue 的 destinationViewController

197
00:10:07,774 --> 00:10:11,843
an image view controller. Okay.
转换为 ImageViewController

198
00:10:11,845 --> 00:10:15,513
So if I, I don't even need the parentheses there, sorry. So
这里不需要大括号，不好意思

199
00:10:15,515 --> 00:10:19,217
if I can get that destination view controller as an image
如果能正确将 destinationViewController 转为

200
00:10:19,219 --> 00:10:24,122
view controller then now I'm ready to prepare this thing.
ImageViewController，那么就可以开始做一些准备了

201
00:10:24,124 --> 00:10:26,024
So, how do I need to prepare it? Well,
怎样去准备呢？

202
00:10:26,026 --> 00:10:29,828
it depends on which button Is doing this show image, okay.
这要取决于哪个按钮触发显示图片事件

203
00:10:29,830 --> 00:10:32,564
So, I'm actually gonna look back at the button. Now,
所以，回头看看这些按钮

204
00:10:32,566 --> 00:10:34,966
here's the button. Remember it prepares for segue.
这个参数就是按钮，并且是谁触发的 segue，

205
00:10:34,968 --> 00:10:38,970
The sender is the button or the line in a table or
那这个 sender 就是谁，可能是按钮或者 table 的某一行

206
00:10:38,972 --> 00:10:40,772
something like that that caused it to happen.
或者其他触发事件的对象

207
00:10:40,774 --> 00:10:43,108
So, I need to convert this into a button. So
所以，我需要将它强转为 button

208
00:10:43,110 --> 00:10:46,411
I could actually do this like this. I could say, if I can
我可以这样做，如果 sender

209
00:10:46,413 --> 00:10:52,017
let the sending button equal the sender as a UI button,
是 UIButton，并解包给 sendingButton 不为空

210
00:10:52,019 --> 00:10:55,887
then I can go forward here and say let's let the image name,
那么就可以定义一个 imageName

211
00:10:55,889 --> 00:10:57,822
that's the name of the image we wanna show,
代表我们想要显示的图片名称

212
00:10:57,824 --> 00:11:02,827
equal the sending button's current title. Oops,
并将 sendingButton 的当前图片，哦，不

213
00:11:02,829 --> 00:11:05,363
not current image, current title. All right, so
当前标题. 

214
00:11:05,365 --> 00:11:06,531
this'll be one way to do this,
这是一种处理方式

215
00:11:06,533 --> 00:11:11,603
okay, but kind of a cool way here is, this is this, right?
但是还有一种更好的方法，看这个和这个

216
00:11:11,605 --> 00:11:14,205
So what if I took this, cut and
如果我将这个

217
00:11:14,207 --> 00:11:17,375
put it in here like that. Okay, so
剪切到这里

218
00:11:17,377 --> 00:11:21,479
I don't need this except for this is If, let. So, if I put
那就不再需要这个 if let 了，但如果

219
00:11:21,481 --> 00:11:24,616
this in here, this is going to be an optional. I can't send
将它放到这里，那这就会是个可选值，不能从可选值

220
00:11:24,618 --> 00:11:28,053
current title to an optional. So, how can I deal with that?
中直接访问 currentTitle 属性. 该怎么办呢？

221
00:11:28,055 --> 00:11:33,124
Let's use optional chaining. Okay? So it's perfectly legal
让我们试试可选链. 在表达式返回可选值的时候

222
00:11:33,126 --> 00:11:36,494
to use the optional chaining stuff on the end of some,
使用可选链来操作

223
00:11:36,496 --> 00:11:39,898
some other expression that returns a possible optional.
是完全合法的

224
00:11:39,900 --> 00:11:42,400
And remember, if this is nil right here,
如果这里是 nil

225
00:11:42,402 --> 00:11:43,868
then this whole thing's just gonna be ignored.
那么之后的都会被忽略

226
00:11:43,870 --> 00:11:46,571
That's what the question mark means, it means if it's nil,
这个问号就是表示可能为 nil

227
00:11:46,573 --> 00:11:48,206
nil then just return nil and ignore it.
遇到 nil 会返回 nil，然后忽略掉

228
00:11:48,208 --> 00:11:52,677
That means imageName is gonna be returned to nil. Okay.
也就是说 imageName 可能为 nil

229
00:11:52,679 --> 00:11:55,947
See how I did that? This cleans up our code a little
接下来做什么呢？先把代码

230
00:11:55,949 --> 00:11:58,616
bit, to do that. Less if then, if thens and
整理一下. 减少分支语句

231
00:11:58,618 --> 00:12:02,554
all that, business around there. Okay? Now I'm going
接下来，要根据

232
00:12:02,556 --> 00:12:06,291
to go get the image that goes with this button's title.
按钮的 title 来获取图片

233
00:12:06,293 --> 00:12:07,659
Now let me show you how we're gonna do that.
让我来演示一下

234
00:12:07,661 --> 00:12:10,462
This DemoURL class, remember the one that had that little
这个 DemoURL 类，有一个 Stanford 的 URL

235
00:12:10,464 --> 00:12:14,165
Stanford URL in there? Well it also had these NASA URLs,
还有 NASA 的 URL

236
00:12:14,167 --> 00:12:16,568
one for Cassini, one for Earth, and one for Saturn.
里面包含 Cassini，Earth 和 Saturn

237
00:12:16,570 --> 00:12:17,802
Those are the three buttons we have. And
对应着我们的三个按钮

238
00:12:17,804 --> 00:12:20,939
I have a little function right here that just gets the name
这还有个简单的方法，接收图片名称

239
00:12:20,941 --> 00:12:24,676
of the image and looks it up in that dictionary right here,
然后在字典中查找

240
00:12:24,678 --> 00:12:27,979
okay, and returns it. So this a little function called
并返回，所以这个方法叫

241
00:12:27,981 --> 00:12:30,815
NASA Image Named. So let's use this NASA Image Named.
NASAImageNamed. 来调用下这个方法

242
00:12:30,817 --> 00:12:35,520
I'm just gonna say right here that the IVC's image URL
在这里写 ivc 的 imageURL

243
00:12:35,522 --> 00:12:41,326
equals the NASAImageNamed this imageName. Okay?
等于 NASAImageNamed 的这个 imageNames

244
00:12:41,328 --> 00:12:46,731
This thing I got right here. >> [COUGH]
就这样

245
00:12:46,733 --> 00:12:47,398
>> All right.
能跟上吗

246
00:12:47,400 --> 00:12:50,502
And then, oops, sorry, this has gotta be DemoURL.,
接下来，哦，不好意思，要加上 DemoURL. 

247
00:12:50,504 --> 00:12:52,670
because it's over here in this DemoURL.
因为这个方法在 DemoURL 中

248
00:12:52,672 --> 00:12:55,306
Notice this is a static function, right?
注意这是个静态方法

249
00:12:55,308 --> 00:12:56,341
NASAImageNamed is static function.
NASAImageNamed 是个静态方法

250
00:12:56,343 --> 00:12:59,611
So, we send it to the class DemoURL, that's why I had to
所以应该用 DemoURL 类来调用，所以

251
00:12:59,613 --> 00:13:05,116
put DemoURL here. Okay, just kind of a utility function for
应该加上 DemoURL. 这只是 DemoURL 中

252
00:13:05,118 --> 00:13:08,820
that little DemoURL class. And while we're at it,
的一个工具方法而已. 接下来，

253
00:13:08,822 --> 00:13:12,323
you know what, let's set the title of that MVC to be that
将 MVC 结构的 title 设置为

254
00:13:12,325 --> 00:13:15,527
image name as well. So that way we'll Earth or Cassini or
图片名字吧. 这样 MVC 的 title 会是 Earth 或 Cassini

255
00:13:15,529 --> 00:13:21,766
whatever as the title of that MVC. Okay so this make sense?
或者其他的名字. 这就是这段代码的作用

256
00:13:22,068 --> 00:13:25,203
Everybody okay now? Let's go ahead and run this and
都能跟上吗？运行程序

257
00:13:25,205 --> 00:13:30,141
see if this is working. Here we go.
看看效果

258
00:13:33,380 --> 00:13:37,081
Okay, there we go. So here's Cassini right here, and
运行起来了，这是 Cassini，

259
00:13:37,083 --> 00:13:41,686
if I click Earth, okay, whoa. So it worked. I clicked Earth
如果我点击 Earth，有点击效果. 点击了 Earth

260
00:13:41,688 --> 00:13:44,923
but nothing's happening in my app. Wait, no there,
但是 app 却没做出响应. 等下，不对啊

261
00:13:44,925 --> 00:13:47,358
it's showing Stanford. Why is is showing Stanford here?
这展示的是斯坦福，为什么会这样？

262
00:13:47,360 --> 00:13:50,361
Well, that's because our nice reusable image view controller
那是因为我们重用的 ImageViewController

263
00:13:50,363 --> 00:13:54,732
we have over here, it's view did load smashes Stanford on
的 viewDidLoad 方法中，将斯坦福盖在了

264
00:13:54,734 --> 00:13:57,435
top of everything. So, that we only put that in there as
所有视图的顶部. 这只是之前的 demo

265
00:13:57,437 --> 00:14:01,105
a demo. Right, so I'm taking that out, sorry about that.
把它提出来，不好意思

266
00:14:01,107 --> 00:14:02,707
Makes everyone see what happened there. So
现在来看看都发生了什么

267
00:14:02,709 --> 00:14:05,143
now let's go back here. It won't be slamming a Stanford
重新运行一次，这下我们的重用 ImageViewController

268
00:14:05,145 --> 00:14:08,880
in there in our reusable image view controller. Okay? So
应该不会被斯坦福盖住了

269
00:14:08,882 --> 00:14:11,182
now we'll go back to Cassini. We'll pick Earth this time.
回到 Cassini 界面，选择 Earth

270
00:14:11,184 --> 00:14:15,119
Again it seems like it's kinda stuck. I can't click on any of
又卡住了. 所有按钮都

271
00:14:15,121 --> 00:14:17,989
these buttons. I can't, actually I can't do anything.
无法点击. 点不了，什么都做不了

272
00:14:17,991 --> 00:14:21,025
There it is. Okay. So that must have been a really big
进来了，真是一张大图

273
00:14:21,027 --> 00:14:24,462
image. It took a very long time to load and here it is.
需要这么长的时间加载，终于显示出来了

274
00:14:24,464 --> 00:14:27,131
It doesn't really look like Earth, but
看起来不怎么像是地球，

275
00:14:27,133 --> 00:14:29,634
pictures of people on Earth, hm. That's interesting.,
倒像是地球上的人，有意思.

276
00:14:29,636 --> 00:14:32,503
Let's try one of these others. Let's try Cassini here. Okay,
再试试别的，试试 Cassini

277
00:14:32,505 --> 00:14:35,106
what happening? This is, basically, just blank.
怎么回事，怎么只有一个白板

278
00:14:35,108 --> 00:14:39,310
What's going on here? How about Saturn? Again,
怎么回事？再试试 Saturn 呢？又来了

279
00:14:39,312 --> 00:14:41,312
taking a really long time, you can see why we're gonna talk
又要等很久，这就是为什么之后我们要讲

280
00:14:41,314 --> 00:14:45,583
about multi-threading a little later. Okay, and here it is,
多线程. 好，进来了

281
00:14:45,585 --> 00:14:47,385
okay that's not good either. All right, so
看起来也不怎么像. 好吧，

282
00:14:47,387 --> 00:14:50,722
we gotta start here. We know the Cassini's not working.
刚才发现 Cassini 没能正常显示

283
00:14:50,724 --> 00:14:53,258
It comes up blank. So why might Cassini not be working.
看到一片空白，为什么会这样

284
00:14:53,260 --> 00:14:56,027
Let's go back here and check for example to make sure that
回到这里，检查下 segue 有没有什么问题

285
00:14:56,029 --> 00:14:59,030
our segue is good. Okay, the Earth's segue. Here's
这是 Earth 的 segue，这是

286
00:14:59,032 --> 00:15:02,667
the Cassini segue. Let';s go look at its identifier.
Cassini 的 segue. 来检查下它的 identifier

287
00:15:02,669 --> 00:15:06,905
Look at that. This Cassini identifier, no identifier.
看到没，Cassini 的 identifier 是空的

288
00:15:06,907 --> 00:15:08,940
So let's put show image in here. Okay?
设置为 Show Image

289
00:15:08,942 --> 00:15:11,743
So when you have a segue and it doesn't seem to be working,
所以，如果你有一个segue，但是没能正常响应

290
00:15:11,745 --> 00:15:12,877
like it segues to the new MVC but
比如想推出一个新的 MVC，但是

291
00:15:12,879 --> 00:15:15,346
the prepared doesn't happen, often you want to go back and
prepare 中的代码没有运行，通常需要回头

292
00:15:15,348 --> 00:15:17,715
look at your identifier, make sure it's set properly or
检查下 identifier，确保它正确的

293
00:15:17,717 --> 00:15:21,419
set in there. Okay, so now, if we go back here.
赋了值. 现在重新运行

294
00:15:25,458 --> 00:15:27,558
All right, we have Cassini here. Let's click on it.
找到 Cassini 并点击

295
00:15:27,560 --> 00:15:30,728
Again, it's loading. That one must be a smaller image.
再次等待加载，这图片应该不大

296
00:15:30,730 --> 00:15:32,797
It loaded pretty quick. And here it is.
加载起来很快，显示出来了

297
00:15:32,799 --> 00:15:36,234
It looks like it's just a bunch of outer space. Okay, so
看起来就只是外太空而已

298
00:15:36,236 --> 00:15:36,935
we've got a problem here,
现在有一个问题

299
00:15:36,937 --> 00:15:39,637
which is that these images that I loaded are huge. That's
当我们加载一些大图的时候

300
00:15:39,639 --> 00:15:44,008
created two problems for us. One, our app get's blocked.
有两个问题摆在了面前. 一个是 app 被卡死了

301
00:15:44,010 --> 00:15:46,878
See I can't click on anything else. I can't even rotate or
任何东西都没办法点击. 连旋转都不行

302
00:15:46,880 --> 00:15:49,547
anything here. My app is just completely stuck.
app 完完全全卡住

303
00:15:49,549 --> 00:15:51,916
You never want your app in that circumstance.
你肯定不想你的 app 出现这样的情况

304
00:15:51,918 --> 00:15:54,652
Never should your app be stuck like that. Users will just,
你们的 app 绝不能出现这样的情况. 用户发现，

305
00:15:54,654 --> 00:15:56,988
basically, double click on the home button and
就会双击 home 键

306
00:15:56,990 --> 00:15:58,456
kill your app and never run it again.
然后杀死进程，再也不会用了

307
00:15:58,458 --> 00:16:00,925
They'll think your app is totally hosed. And it is,
他们会觉得你的 app 太烂了，这就是

308
00:16:00,927 --> 00:16:04,228
if it behaves that way, okay, so we really need to fix that.
界面卡死的后果，所以我们需要修复下

309
00:16:04,230 --> 00:16:06,197
The other thing is, this image is so
另外一个问题就是，图片太大

310
00:16:06,199 --> 00:16:09,500
huge that we can't really see it. So we'd like to be able to
无法直观的展示. 所以我们要添加

311
00:16:09,502 --> 00:16:11,936
zoom in on it, right. So let's go ahead and
缩放功能. 先来处理

312
00:16:11,938 --> 00:16:17,508
do the zooming, okay? How do we do the zooming in our,
缩放吧. 怎么在 ImageViewController 中

313
00:16:18,178 --> 00:16:19,844
back here in our image view controller, right?
做缩放呢？

314
00:16:19,846 --> 00:16:22,146
So our image view controller has this scroll view,
ImageViewController 有一个 scrollView

315
00:16:22,148 --> 00:16:24,983
right? That we dragged into the storyboard. It's got this
我们拖到 storyboard 中的. 并将 imageView 添加

316
00:16:24,985 --> 00:16:28,453
image view as the subview of the scroll view. Okay, and
到了 scrollView 上

317
00:16:28,455 --> 00:16:31,556
we set our content size, so it's working nicely. And
我们还设置了 contentSize，看起来非常棒

318
00:16:31,558 --> 00:16:32,857
we know from the slides last time that
从之前的幻灯片我们知道了

319
00:16:32,859 --> 00:16:37,495
to make zooming work. Okay, we need to set some other things.
缩放的原理. 那这里还需要处理一些东西

320
00:16:37,497 --> 00:16:39,364
What are some of the things we need to do? Well,
需要怎么做呢？

321
00:16:39,366 --> 00:16:42,600
the most important thing is we need to set ourselves
最重要的一点，就是要将我们自己设置为

322
00:16:42,602 --> 00:16:44,135
as the scrollView's delegate. Okay, so
scrollView 的 delegate.

323
00:16:44,137 --> 00:16:48,373
this is the first time you're seeing delegation demoed here.
这是我们在 demo 中第一次用到 delegate

324
00:16:48,375 --> 00:16:48,773
And the way we do that,
我的做法是

325
00:16:48,775 --> 00:16:52,844
I'd probably do it here in my scrollView didSet here, right?
在 scrollView 的 didSet 方法中来设置

326
00:16:52,846 --> 00:16:55,680
The didSet for my scrollView. Probably just say that Mr.
这就是 scrollView 的 didSet 方法. 这样说，

327
00:16:55,682 --> 00:17:00,084
scrollView, please set your delegate to be self. In other
亲爱的 scrollView，让我成为你的代理吧！换句话说，

328
00:17:00,086 --> 00:17:04,856
words, send me any questions you have about how to operate.
就是把你的问题抛给我来处理吧

329
00:17:04,858 --> 00:17:07,125
Now when I put that in there I have a error,
照我这样设置出现了一个错误

330
00:17:07,127 --> 00:17:11,796
anyone guess what this error is? Okay,
有谁知道这是什么错误吗？

331
00:17:11,798 --> 00:17:14,699
it's going to say that these types, this and
错误是说，他们的类型，这个和

332
00:17:14,701 --> 00:17:18,870
this do not match. Okay, and why is that? The type of this
这个不匹配. 为什么呢？这个的类型是...

333
00:17:18,872 --> 00:17:22,006
is, well the type of this, not showing, but the type of this
好吧，看不到，但是这个的类型是

334
00:17:22,008 --> 00:17:27,211
is UI scrollView delegate. Which is a protocol, okay.
UIScrollViewDelegate. 是个协议

335
00:17:27,213 --> 00:17:31,883
The type of this is UI or image view controller.
这个类型是 UI...哦，是ImageViewController

336
00:17:31,885 --> 00:17:34,652
That's its type. Those don't match. Okay, so
这就是它们的类型，并不匹配. 难怪

337
00:17:34,654 --> 00:17:38,523
that's why this says cannot assign value of type image
报错说不能将 ImageViewController

338
00:17:38,525 --> 00:17:42,260
view controller to UI scroll view delegate, optional.
赋值给可选的 UIScrollViewDelegate

339
00:17:42,262 --> 00:17:46,230
Okay, so we need to say that this image view controller is
所以，我们要先让 ImageViewController 遵循

340
00:17:46,232 --> 00:17:51,736
a UI scroll view delegate. And we do that by just putting
UIScrollViewDelegate. 需要做的是，将 UIScrollViewDelegate 声明在

341
00:17:51,738 --> 00:17:54,672
that right after our super class there, a little comma,
父类的右边，逗号分隔

342
00:17:54,674 --> 00:17:57,642
UIScrollViewDelegate, and that says we are scroll view
这表明我们就是 scrollView

343
00:17:57,644 --> 00:18:00,178
delegate, and all of a sudden this works.
的代理，这样就没问题了

344
00:18:00,180 --> 00:18:03,047
Now UIScrollViewDelegate has no methods or
UIScrollViewDelegate 没有方法或

345
00:18:03,049 --> 00:18:05,950
vars in there that are not optional. In other words
变量是不可选的，换句话说，

346
00:18:05,952 --> 00:18:08,853
they're all optional, so we've successfully implemented so
它们都是可选的，所以，遵循以后

347
00:18:08,855 --> 00:18:10,688
the compiler's not complaining. Okay,
编译器并没有报错

348
00:18:10,690 --> 00:18:14,725
cuz none of them are required. But, we still wanna implement
因为没有必须实现的方法. 不过我们还是需要实现

349
00:18:14,727 --> 00:18:17,995
one, that zooming one, which is called
其中一个方法，缩放的那个，叫做

350
00:18:17,997 --> 00:18:19,363
viewForZoomingInScrollView. Now, one
viewForZoomingInScrollView. 在你

351
00:18:19,365 --> 00:18:21,632
thing that's cool is once you say that you're a ScrollView
成为 ScrollView 的代理之后，

352
00:18:21,634 --> 00:18:24,735
delegate, look what happens when I start typing view
在最新的 Xcode 键入字母时

353
00:18:24,737 --> 00:18:26,971
in Xcode. It knows I'm a ScrollView delegate, so
它就知道你已经是 ScrollView 的代理了，所以

354
00:18:26,973 --> 00:18:30,308
the very first thing it offers me is viewForScroll,
提供的首个联想方法就是 viewForScroll

355
00:18:30,310 --> 00:18:33,177
ScrollingInScrollView. For
ZoomingInScrollView（白胡子口误了）

356
00:18:33,179 --> 00:18:36,981
zooming in scrollView.、 Right? So that's kind of cool. And
用做 scrollView 的缩放. 这真的非常棒

357
00:18:36,983 --> 00:18:40,017
what view, which of the scrollView subviews do we want
那个视图？我们想让 scrollView 的哪个子视图

358
00:18:40,019 --> 00:18:44,622
to zoom in on? Well, of course, the image view. This
做缩放？当然是 imageView. 这是

359
00:18:44,624 --> 00:18:48,159
is our image view right here that we store our image in.
我们的 imageView，里面存储了相应图片

360
00:18:48,161 --> 00:18:49,494
That's of course the thing we want
很明显我们是想

361
00:18:49,496 --> 00:18:54,599
to have its transform modified when we pinch in there. Okay?
在手指捏合的时候，对图片做对应的缩放

362
00:18:54,601 --> 00:18:56,400
Now you might think okay, that's good.
你可能会想，那已经完成了，

363
00:18:56,402 --> 00:19:00,505
Got it all ready to go. Let's go start zooming, and
可以运行了. 让我来看看缩放效果吧

364
00:19:00,507 --> 00:19:03,341
we'll go over here. Let's get Cassini, kinda small.
到这个界面，打开 Cassini，一张小图

365
00:19:03,343 --> 00:19:06,277
Let's start zooming. Now how do I zoom? It's with Pinch, so
试试缩放. 怎么进行缩放呢？需要捏合手势，所以

366
00:19:06,279 --> 00:19:08,913
I'm gonna hold down the Option key right here and
按住 Option 键，然后

367
00:19:08,915 --> 00:19:11,048
start pinching. And it's not working.
进行捏合. 但并没有效果

368
00:19:11,050 --> 00:19:14,085
It's not doing anything. Okay, I can still scroll but
完全没有效果. 依然可以滚动，但是

369
00:19:14,087 --> 00:19:18,990
I can't zoom in. Anyone know why? Say
不能缩放. 有人知道为什么吗？大点声.

370
00:19:18,992 --> 00:19:25,396
it louder. I think I might have heard it back there.
我刚才好像听到那有人回答.

371
00:19:25,398 --> 00:19:28,065
Yeah, this right now, our scrollView by default,
是的，没错，现在 scrollView 的默认值是

372
00:19:28,067 --> 00:19:31,836
it's maximum zoom and its minimum zoom is 1.0.
放大倍数和缩小倍数都是 1.0

373
00:19:31,838 --> 00:19:33,738
So it is zooming to the maximum,
所以我们放大

374
00:19:33,740 --> 00:19:36,974
minimum extent we allow which is none, 1.0. So
和缩小的效果根本看不出来，都是 1.0，所以

375
00:19:36,976 --> 00:19:41,779
we need to set the maximum and minimum scrolling factor or
我们需要给 scrollView 的范围因子，或叫做给

376
00:19:41,781 --> 00:19:45,583
zooming factor on this scrollView. So let's do that.
缩放因子赋值. 回到代码.

377
00:19:45,585 --> 00:19:48,386
Let's do that also right here when we're setting our
在这里进行设置，在

378
00:19:48,388 --> 00:19:50,254
scrollView from our storyboard. So
scrollView 在 storyboard 中被赋值时调用的方法

379
00:19:50,256 --> 00:19:52,924
we just say that the scrollView's minimum zoom
键入 scrollView 的 minimumZoomScale

380
00:19:52,926 --> 00:19:57,962
scale. I'm gonna have this minimum zoom scale.
来设置最小缩放因子

381
00:19:57,964 --> 00:20:02,433
What did I think that worked well here? 0.03.
设成多少效果比较好呢？0.03 吧

382
00:20:02,435 --> 00:20:04,735
So we're gonna zoom- allowed to zoom way out.
我们可以进行缩放

383
00:20:04,737 --> 00:20:07,205
So it will make the image really small, okay?
图片会缩小到很小

384
00:20:07,207 --> 00:20:10,975
Three one-hundredths of it's size.
是原图的百分之三

385
00:20:10,977 --> 00:20:13,844
3% of its size. And then the maximum,
也就是 3% 的大小，接下来设置最大因子

386
00:20:13,846 --> 00:20:16,480
it is perfectly fine for us to say the maximum is 1.0.
这个值设为 1.0 就好了

387
00:20:16,482 --> 00:20:20,318
Maybe we never want the thing to be zoomed out any bigger
可能我们永远不会将该图片放大

388
00:20:20,320 --> 00:20:23,020
than it already is, especially there are huge images already.
毕竟它已经是一张很大的图片了

389
00:20:23,022 --> 00:20:26,190
So we can set the maximum to zoom scale. We don't even need
其实我们完全可以不用设置放大因子，这条

390
00:20:26,192 --> 00:20:29,060
to put this. Cuz by default, it's 1.0. But we'll put it
语句可以不用谢，因为默认值就是 1.0. 这里就不删了，

391
00:20:29,062 --> 00:20:32,430
in here just to kinda be very clear about what we're doing.
看着更清晰一点

392
00:20:32,432 --> 00:20:39,737
All right, so now lets try it. All right,
再来看看效果

393
00:20:39,739 --> 00:20:44,542
so lets go get Cassini right here. All right, here it is.
点击 Cassini，然后

394
00:20:44,544 --> 00:20:48,212
Lets zoom in on it, right. I'm pinching. Yeah, look at that,
进行缩放，捏合一下，看到了吧

395
00:20:48,214 --> 00:20:50,314
it's zooming. And sure enough, look,
缩小了. 效果很好

396
00:20:50,316 --> 00:20:54,352
there's Cassini. Taking a little trip by Saturn, okay,
这是 Cassini，在围着 Saturn 兜风

397
00:20:54,354 --> 00:20:57,021
let's zip it around here so we can see a little better. Okay,
旋转一下屏幕，就能看到更多内容

398
00:20:57,023 --> 00:21:00,324
how about some of these other images, go look at the Earth,
来看看其他图片呢，看看 Earch

399
00:21:00,493 --> 00:21:03,861
didn't look like much like Earth. Now if we zoom,
之前看着并不像 Earth. 这次缩小试试

400
00:21:03,863 --> 00:21:07,131
we'll see something here. All right, so here it is,
说不定能看到更多东西. 好了，加载出来了

401
00:21:07,133 --> 00:21:11,802
scrolling around, I'm gonna pinch, pinch some more.
滚动看看，然后捏合，再缩小点

402
00:21:11,804 --> 00:21:17,675
Look at this Earth, okay? Same thing with Saturn.
啊哈，这就是 Earch. 在看看 Saturn 呢

403
00:21:18,111 --> 00:21:20,244
Okay, everyone see what we do with the zooming?
每个人都知道怎么实现缩放了吗？

404
00:21:20,246 --> 00:21:21,279
Zooming quite simple
实现起来真的很简单

405
00:21:21,281 --> 00:21:22,847
in terms of the code you have to write, but
就那么几句代码

406
00:21:22,849 --> 00:21:24,882
you have to understand that delegation piece for
这全都要靠 delegate

407
00:21:24,884 --> 00:21:28,152
it to really, to make it work. And you'll see Saturn,
那才是真谛. 来看看 Saturn

408
00:21:28,154 --> 00:21:34,325
there's Saturn. Okay? Now let's try this on iPad,
这是 Saturn. 没问题，运行在 iPad 上试试，

409
00:21:34,327 --> 00:21:37,528
okay? Let's see what it looks like here.
看看显示效果

410
00:21:47,373 --> 00:21:48,906
All right, so here is our master and
这是 master

411
00:21:48,908 --> 00:21:51,542
our detail right here. So if I click on Cassini,
这是 detail，点击 Cassini，

412
00:21:51,544 --> 00:21:54,912
hopefully Cassini will eventually really slow,
加载起来确实很慢

413
00:21:54,914 --> 00:21:57,315
appear right here. Okay? And we can zoom in here, okay?
显示出来了，缩放试试呢

414
00:21:57,317 --> 00:22:02,119
Now, what would be really cool here is if we could have
如果在这里能有个标题

415
00:22:02,121 --> 00:22:05,856
a title up here that said this was Cassini,
告诉我们这是 Cassini，

416
00:22:05,858 --> 00:22:09,560
or Earth, or Saturn, right? So remember
还是是 Earth，是 Saturn，就更好了

417
00:22:09,562 --> 00:22:12,863
the tricky way we did that, is we went to our storyboard, and
其实有一个很取巧的方式，打开 storyboard

418
00:22:12,865 --> 00:22:17,201
we just put this one down here. Also in the scrollView.
将下面的这个包含 scrollView 的控制器

419
00:22:17,203 --> 00:22:19,704
So we said embed in navigation control.
加上 navigation

420
00:22:19,706 --> 00:22:21,872
Or not in a scrollView, in a navigation controller. So
或者嵌入到 navigation controller 中

421
00:22:21,874 --> 00:22:25,910
I embed it in there, so that now I have a title. Right? And
嵌入之后，就可以设置标题了

422
00:22:25,912 --> 00:22:26,644
we know that if we can go and
如果现在运行

423
00:22:26,646 --> 00:22:29,547
run this, it's not going to work, right? Because these
不会有任何效果，因为

424
00:22:29,549 --> 00:22:33,984
segues are segueing now to a navigation controller. And
现在这个 segue 是 navigation controller 了.

425
00:22:33,986 --> 00:22:36,687
so our prepare is not gonna work,
所以 prepare 方法不会有效

426
00:22:36,689 --> 00:22:40,124
cuz this line of code is going to fail. Right,
这句代码代码判断失败了

427
00:22:40,126 --> 00:22:43,394
because the destination view controller is now a navigation
现在这个 destinationViewController 是 navigationController

428
00:22:43,396 --> 00:22:43,594
controller. Of course,
显然，

429
00:22:43,596 --> 00:22:46,063
a navigation controller is not an image view controller.
navigationController 不是 imageViewController

430
00:22:46,065 --> 00:22:48,165
This is the exact same problem we had before. So
这种问题我们之前遇到过

431
00:22:48,167 --> 00:22:51,869
I'm gonna show you now how to use that extensions mechanism
下面我将演示如何使用 extension 来

432
00:22:51,871 --> 00:22:54,805
to fix this. So I'm gonna create an extension. This is
解决这个问题. 先创建一个 extension. 

433
00:22:54,807 --> 00:22:59,143
exactly what I did in the slides of UIViewController.
这是给 UIViewController 的 extension.

434
00:23:00,012 --> 00:23:03,481
Okay, and in this extension, like to scroll up a little so
好的，在 extension 中，好像往下滚动一点

435
00:23:03,483 --> 00:23:07,351
you can see it better. Okay, inside this extension,
更方便你们看. 好的，在这个 extension 中，

436
00:23:07,353 --> 00:23:11,689
I'm gonna add the var contentViewController.
我准备添加一个 contentViewController 变量.

437
00:23:11,691 --> 00:23:14,525
Which is a UIViewController, okay?
类型是 UIViewController

438
00:23:14,527 --> 00:23:17,862
I'm adding this var to the class UIViewController.
这是给 UIViewController 添加的变量

439
00:23:17,864 --> 00:23:21,232
So, all UIViewControllers will now respond to this property
所以所有的 UIViewController 都有一个叫做

440
00:23:21,234 --> 00:23:24,568
contentViewController. Okay? It's gonna be get only.
contentViewController 的属性了. 将它声明为只读属性.

441
00:23:24,570 --> 00:23:27,171
It's gonna get it. And what I'm gonna put in here is
直接就能获取值. 这里的代码和

442
00:23:27,173 --> 00:23:29,907
basically that same code I had in prepareforSegue,
motion view controller 中的 prepareforSegue 方法

443
00:23:29,909 --> 00:23:32,309
in a motionview controller. I'm gonna say,
代码相同，这样写，

444
00:23:32,311 --> 00:23:37,915
if I can let navcon = self as a UINavigationController,
if let navcon = self as? UINavigationController，

445
00:23:37,917 --> 00:23:43,120
so in otherwords, if I am a navigation controller,
意思是，如果 self 是 UINaviagtionController，

446
00:23:43,122 --> 00:23:47,858
then return navcon.visibleViewController.
就返回 navcon.visibleViewController.

447
00:23:47,860 --> 00:23:50,594
Okay? The only problem with this is this is
这里唯一的问题就是

448
00:23:50,596 --> 00:23:53,631
an optional view controller, because the navigation
这个 view controller 是可选值，因为 navigation

449
00:23:53,633 --> 00:23:56,700
controller might not have anything showing. Okay, so
controller 可能不会展示任何信息，所以

450
00:23:56,702 --> 00:24:00,237
I need to return something because contentViewController
这里必须要返回一个确切的值，因为 contentViewController

451
00:24:00,239 --> 00:24:02,940
does not return an optional So I'm gonna use this
不是一个可选类型. 所以我准备用 ?? 将默认值

452
00:24:02,942 --> 00:24:06,210
defaulting to say if I have a NavigationController and
设置为 self，如果有 NavigationController

453
00:24:06,212 --> 00:24:08,779
it has no visible ViewController, just return
但是 visibleViewController 为空的话，就返回

454
00:24:08,781 --> 00:24:12,082
self, which is to say the NavigationController itself,
self，也就是 NavigationController

455
00:24:12,084 --> 00:24:14,819
okay? Otherwise, we can just return self. So if it's not
其他情况，就返回 self. 即如果不是

456
00:24:14,821 --> 00:24:17,655
a NavigationController, then the content is myself.
NavigationController，就返回 self 作为 content

457
00:24:17,657 --> 00:24:22,293
Everyone understand that code right there? Okay? Good.
大家对这段代码有疑问吗？没有？好的. 

458
00:24:22,295 --> 00:24:25,296
So, now that we have this, we can just use that method right
有了这个以后，我们在这里直接调方法就可以了.

459
00:24:25,298 --> 00:24:29,400
here. Okay? Instead of asking if the destination can view
这里还要把之前判断的 destination view 

460
00:24:29,402 --> 00:24:31,535
controller is an image view controller, I'm gonna ask if
controller 是 imageViewController 改为判断

461
00:24:31,537 --> 00:24:36,240
the destination controller's content view controller, and
destination controller 的 content view controller 是否是 

462
00:24:36,242 --> 00:24:38,742
I can escape complete, cuz now that's a method on U, I,
imageViewController. 现在这个方法，哦，这个


463
00:24:38,744 --> 00:24:41,579
this is a UI view controller. This is a method on UI view
就是 UIViewController 了，这个方法就是 UIViewController 的

464
00:24:41,581 --> 00:24:44,381
controller. I'm just gonna ask if the content view controller
只需要判断 content view controller 是否

465
00:24:44,383 --> 00:24:49,954
is an image view controller. Okay? So now we should be able
是 image view controller 就行了. 现在在 iPad 上跑起来

466
00:24:49,956 --> 00:24:54,825
to run an iPad and get some nice titles. All right.
应该就可以看到标题了.

467
00:24:54,827 --> 00:24:58,162
Cassini again. We've got the navigation controller up here.
依然打开 Cassini，能看到这里有个 navigation controller

468
00:24:58,164 --> 00:25:00,297
There's Cassini. Sure enough, there's the title, right.
这是 Cassini，没问题，这是标题

469
00:25:00,299 --> 00:25:04,568
We set the title right here. Ivc.title = imageName, okay?
我们在这里加上了标题，ivc.title = imageName

470
00:25:04,570 --> 00:25:11,275
And of course, we can zoom around, okay?
当然，我们还可以进行缩放

471
00:25:11,277 --> 00:25:13,310
All right, any questions about that before I go back to
讲到这里，大家有什么问题吗？

472
00:25:13,312 --> 00:25:18,449
the slides? All right. Let's hit the slides here.
好的，再回到讲义.

473
00:25:23,689 --> 00:25:26,524
Okay, so now we're gonna talk about multithreading, so
接下来，我会讲讲多线程

474
00:25:26,526 --> 00:25:28,592
we can fix that problem where our Cassini app,
这样就能修复 Cassini app 中，当我们加载大图时

475
00:25:28,594 --> 00:25:31,962
when we click on the big image, it just froze. Okay.
导致的界面卡死问题了.

476
00:25:31,964 --> 00:25:36,033
When you build an app, never have it freeze like that ever.
当你做一款 app 时，千万不要出现界面卡死的情况

477
00:25:36,035 --> 00:25:38,435
In fact, if it freezes like that, probably you won't get
事实上，出现界面卡死的情况，

478
00:25:38,437 --> 00:25:41,605
through the app store approval process. Okay. So the only
还会影响你上架 app store. 解决界面卡死的

479
00:25:41,607 --> 00:25:44,808
way to stop it from freezing is to use multithreading.
唯一方式，就是使用多线程.

480
00:25:44,810 --> 00:25:48,646
Okay. So, multithreading just means we're going to
多线程意味着我们会在

481
00:25:48,648 --> 00:25:50,781
have different threads of execution,
不同的线程中执行任务

482
00:25:50,783 --> 00:25:54,118
okay? Different places in, in our iPhone or
在，在 iPhone 或 iPad 的不同的地方

483
00:25:54,120 --> 00:25:56,887
our iPad where code is running, okay?
执行代码

484
00:25:56,889 --> 00:26:00,090
And these, these appear to run simultaneously, but
这些代码，几乎是同时运行的，

485
00:26:00,092 --> 00:26:03,227
it'll even work on a single core processor, okay,
即使在单核处理器上，也没问题

486
00:26:03,229 --> 00:26:07,231
not a multiprocessor. It works, then, by timesharing.
虽然不是多核处理，但是运用了分时操作手段

487
00:26:07,233 --> 00:26:08,399
Okay. And so you got one thing running,
所以，一个事件在执行，

488
00:26:08,401 --> 00:26:09,867
another thing running and it's kinda going back and
然后再切换到另一个事件，执行后又切回刚才的事件

489
00:26:09,869 --> 00:26:13,304
forth. Letting them each run a little bit and maybe if one of
继续执行. 每个事件都能执行一段时间，如果某个事件

490
00:26:13,306 --> 00:26:15,573
them's more important than the other, it gets run a lot and
在其中比较重要，那么就会停留得就一些，

491
00:26:15,575 --> 00:26:18,576
the other one doesn't get to run so much. Okay? But
次要的事件就不会占用那么长事件.

492
00:26:18,578 --> 00:26:21,545
that's basically what multithreading is all about.
这就是多线程最基础的部分.

493
00:26:21,547 --> 00:26:22,079
So how many people have,
在做的有同学已经，

494
00:26:22,081 --> 00:26:25,583
have done any multithreading programming of any kind? Okay,
已经做过多线程的项目了？好吧，

495
00:26:25,585 --> 00:26:28,586
so some of you have, okay. About a little less than half
一部分同学，大概不到一半的人吧。

496
00:26:28,588 --> 00:26:31,722
of you. Okay, good. So in iOS multithreading is about
谈到 iOS 上的多线程，其实都是

497
00:26:31,724 --> 00:26:35,859
queues, okay? Queue meaning like, if you go to the movies
队列. 队列就像是...如果你在 England 去

498
00:26:35,861 --> 00:26:37,895
maybe in England [LAUGH] they would say, well,
看电影，那么他们会说，

499
00:26:37,897 --> 00:26:40,664
get in the queue, meaning the line to get into the movie,
排队去，意思是，排队依次进电影院.

500
00:26:40,666 --> 00:26:43,901
okay? So same thing here, and it's the same thing as queue
这里的队列和计算机科学中队列

501
00:26:43,903 --> 00:26:46,971
in the computer science sense, right? A queue is a thing,
的含义是一样的. 队列其实就是一个东西，

502
00:26:46,973 --> 00:26:48,973
a bunch of things lined up to do something.
一个有先后顺序的东西.

503
00:26:48,975 --> 00:26:54,912
All right. And these queues contained an iOS functions.
这些队列包含了 iOS 的方法.

504
00:26:54,914 --> 00:26:58,482
Okay? Most of the time these functions are closures. Okay?
绝大多数方法都是闭包. 好吧？

505
00:26:58,484 --> 00:27:02,052
That you've put in there. Okay? Blocks of code that you
然后加入到队列中. 就是闭包中的代码，

506
00:27:02,054 --> 00:27:06,824
put in this queue. Okay? And then, the system simply runs
加入到队列中. 接着，系统会单独运行

507
00:27:06,826 --> 00:27:09,693
along this queue, pulls the next thing off the queue and
这个队列，将队列中的任务取出，

508
00:27:09,695 --> 00:27:13,430
starts it running in a separate thread, okay?
然后在独立的线程中运行.

509
00:27:13,432 --> 00:27:16,100
And you can have multiple of these queues and the system is
你也可以有很多个队列，然后系统便会

510
00:27:16,102 --> 00:27:18,602
pulling them off each one and running them un, in their
分别取出，然后...在各自的线程中

511
00:27:18,604 --> 00:27:21,705
own threads, simple as that, you just got multithreading.
执行，就这么简单的用上了多线程.

512
00:27:21,707 --> 00:27:24,642
Okay. Now there's a little bit of trickiness
那么现在有个问题，

513
00:27:24,644 --> 00:27:25,909
here of what are these queues and
队列是什么，

514
00:27:25,911 --> 00:27:27,444
how do you put things on the queues, but
怎么将任务加入到队列中，

515
00:27:27,446 --> 00:27:30,180
that's the fundamental way these work. Now queues can
这属于队列运行原理. 队列可以是

516
00:27:30,182 --> 00:27:34,118
either be serial, which means the function that's on the top
串行的，意思是只有当上一个任务执行完后，

517
00:27:34,120 --> 00:27:37,154
of the queue gets pulled off, it runs to completion, and
新的队首元素才会出队

518
00:27:37,156 --> 00:27:40,824
then the next one gets pulled off. That's serial queues. Or
接着执行. 这就是串行队列.

519
00:27:40,826 --> 00:27:43,494
they can be concurrent, where the system pulls the top
队列也可以是并行的，意思是系统出队

520
00:27:43,496 --> 00:27:46,130
one off the queue, starts it running in a thread. If it's
一个队首元素，就立即在一个线程中执行. 如果是这样，

521
00:27:46,132 --> 00:27:48,599
got more thread resources, it takes the next one off,
就会占用更多的资源，下一个任务出队以后

522
00:27:48,601 --> 00:27:51,402
starts it running in another thread while the first one's
就会在另一个线程中进行执行，此时，第一个出队的任务

523
00:27:51,404 --> 00:27:51,502
still running, and
仍在执行，

524
00:27:51,504 --> 00:27:55,873
it might keep pulling a whole bunch of them off. Okay, so
这种队列甚至可以直接将整个队列元素出队执行. 

525
00:27:55,875 --> 00:27:57,775
that's a concurrent queue.
这就是并行队列.

526
00:27:57,777 --> 00:28:00,544
All right, so let's talk about the queues, how we get them,
接下来，再来看看队列的其他知识. 我们怎么获得队列，

527
00:28:00,546 --> 00:28:03,781
what, what we call them, etc. The most important queue,
怎样调用它们，等等. 对重要的队列，

528
00:28:03,783 --> 00:28:06,717
it's a serial queue called the main queue, okay?
就是一个称为主队列的串行队列.

529
00:28:06,719 --> 00:28:10,554
The main queue is where all UI activity has to happen. And
主队列是刷新 UI 控件的队列. 

530
00:28:10,556 --> 00:28:14,658
this is super important for you to understand. That if you
大家一定要着重理解这个知识点. 如果你在

531
00:28:14,660 --> 00:28:19,063
want to do anything where you call something a UI kit, okay,
做一些和 UIKit 相关的动作，比如

532
00:28:19,065 --> 00:28:21,331
UI button, UI anything, all right,
UIButton，或其他 UI 元素，

533
00:28:21,333 --> 00:28:24,334
with a couple of exceptions which I'll talk about later.
包括之后我们还会学到的其他 UI 控件. 

534
00:28:24,336 --> 00:28:27,104
You need to be making those calls on the main queue.
它们都必须要在主队列中进行操作.

535
00:28:27,106 --> 00:28:31,241
In other words, you can't put those calls in a closure that
换句话说，它们不能再其他队列的闭包

536
00:28:31,243 --> 00:28:34,378
you put on some other queue. Okay, it has to be on the main
中执行. 必须在主队列中执行》 

537
00:28:34,380 --> 00:28:39,149
queue, all right? Now conversely, all non-UI
记住了吗？相反，所有和 UI 控件

538
00:28:39,151 --> 00:28:42,519
activity that's gonna take any amount of time or resources,
无关的操作，可能会耗时，或耗资源的操作，

539
00:28:42,521 --> 00:28:45,589
probably wants to be off the main queue. So it never blocks
就不要放到主队列中. 千万不要阻塞

540
00:28:45,591 --> 00:28:48,092
the main queue. We want the main queue reserved for
主队列. 我们应该尽可能的将主队列的资源

541
00:28:48,094 --> 00:28:51,562
doing our UI stuff as much as possible. Okay, now this is
用来调度 UI 元素. 当然，希望 UI 控件能及时响应

542
00:28:51,564 --> 00:28:55,799
not only cuz we want our main queue UI to be responsive,
只是其中一个原因，

543
00:28:55,801 --> 00:28:56,767
okay, that's the main reason, but
也是最主要的原因，另外

544
00:28:56,769 --> 00:29:00,671
also it serializes the activity on the main queue so
一个原因，是因为主队列是串行队列，所以

545
00:29:00,673 --> 00:29:03,907
that our UI is presented in an orderly fashion. If,
UI 元素能按照我们给的顺序来执行. 如果，

546
00:29:03,909 --> 00:29:06,343
if we allowed our UI to be on all these different queues, it
如果允许在不同的队列中操作 UI，实际上却是是

547
00:29:06,345 --> 00:29:08,912
could, things would be drawing at all different rates and
可以的，但是绘制速度就会不同，从而出现

548
00:29:08,914 --> 00:29:09,480
overlapping, it would be
重叠，预测不了

549
00:29:09,482 --> 00:29:11,882
unpredictable as to what happened on screen. Okay, so
界面效果. 所以

550
00:29:11,884 --> 00:29:15,285
we use the main queue as kind of a synchronization point
我们需要要利用主队列的同步性，

551
00:29:15,287 --> 00:29:18,522
where everybody comes back to draw on the main queue,
保证所有的绘制都在主队列中进行，

552
00:29:18,524 --> 00:29:22,259
all right? Now the main queue can only pull a closure or
明白了吗？主队列每次会出队一个闭包或

553
00:29:22,261 --> 00:29:24,294
a function off of the main queue and
一个方法，

554
00:29:24,296 --> 00:29:26,630
work on it when it's quiet. In other words,
在静默时，执行它. 换句话说，

555
00:29:26,632 --> 00:29:28,532
it's not off doing something else, like drawing or
它一直都是执行状态，比如在绘制，或

556
00:29:28,534 --> 00:29:31,835
something like, like that. Now the system is using the main
在执行和绘制差不多的任务. 主队列会一直在

557
00:29:31,837 --> 00:29:33,403
queue behind the scenes all the time.
系统后台运行着.

558
00:29:33,405 --> 00:29:35,572
For example, you know about draw req. Right.
比如，你知道绘制操作吧.

559
00:29:35,574 --> 00:29:38,342
I told you draw req gets called by the system and
我之前说过，绘制是系统在调用，

560
00:29:38,344 --> 00:29:40,277
it doesn't get called, you don't call it,
你并没有手动去调用，

561
00:29:40,279 --> 00:29:42,913
you don't tell it to, you just set needs display.
并没有让系统去调，只是告诉系统它需要显示.

562
00:29:42,915 --> 00:29:44,348
Well, you set needs display and
设置在主线程空闲的时候

563
00:29:44,350 --> 00:29:48,585
as soon as the main queue gets quiet, it goes and runs some
进行显示，系统会运行或调用某些

564
00:29:48,587 --> 00:29:51,555
function that causes that draw req to be called. So
方法来进行绘制. 这便是

565
00:29:51,557 --> 00:29:54,525
you see how that works, okay? So that's what's going on in
绘制的工作原理. 这便是主队列

566
00:29:54,527 --> 00:29:57,294
the main queue. What about other queues? Okay, so
在处理的东西. 那么其他队列呢？看

567
00:29:57,296 --> 00:30:00,030
there's, I'm, in the next slide I'm gonna talk about
这里，下个话题便会讲讲

568
00:30:00,032 --> 00:30:02,800
two different kinds of other queues that you can use to run
其他两种不同的队列，能用来处理

569
00:30:02,802 --> 00:30:06,236
all your non-UI stuff. All right? So the first,
所有和 UI 无关的队列. 目前，

570
00:30:06,238 --> 00:30:09,039
not gonna talk about this now, that'll be on the next slide.
我们暂时不谈这个，这是下个话题.

571
00:30:09,041 --> 00:30:12,142
So on this slide I'm gonna talk a little bit about how we
这张幻灯片还有一点东西没讲完，关于如何

572
00:30:12,144 --> 00:30:14,845
put something on a queue and the main way we do it is
将任务放到队列中，最常见的做法是

573
00:30:14,847 --> 00:30:17,981
with this function right here called dispatch_async.
调用一个叫 dispatch_async 的方法.

574
00:30:17,983 --> 00:30:22,986
Dispatch_async takes two arguments. One is the queue to
Dispatch_async 有两个参数. 一个是要加入的

575
00:30:22,988 --> 00:30:25,455
put it on, like the main queue or one of these other queues,
队列，可以是主队列，或者其他队列，

576
00:30:25,457 --> 00:30:29,760
and the second argument is the function to put on the queue,
第二个参数是，要加入队列的方法，

577
00:30:29,762 --> 00:30:32,963
again, usually it's a closure. You see how I'm using trailing
当然，通常是闭包. 我这里简单写了一个

578
00:30:32,965 --> 00:30:35,933
closure syntax right there? Okay. This is two arguments.
闭包的语法. 这有两个参数，

579
00:30:35,935 --> 00:30:39,002
One argument. Two arguments. So this is the closure you're
一个参数. 两个参数. 这就是加入到队列中的

580
00:30:39,004 --> 00:30:41,605
gonna put on there. What's cool about these closures,
闭包. 看起来很不错吧，

581
00:30:41,607 --> 00:30:43,607
they take no arguments and then return no arguments.
闭包没有参数，也没有返回值.

582
00:30:43,609 --> 00:30:46,910
So they're really easy to, to [LAUGH] put into your code.
所以，非常容易嵌到你的代码中（笑~

583
00:30:46,912 --> 00:30:50,180
Okay? And you can put anything you want in here. Okay?
你可以将任何想执行的代码扔到里面.

584
00:30:50,182 --> 00:30:53,884
But if this gonna do UI, you better not put it on anything
当然，最好是将 UI 操作扔进去，而不是别的操作，

585
00:30:53,886 --> 00:30:58,388
but the main queue. All right, so how do you get the queue?
毕竟这是主线程. 所以，怎样获得一个队列呢？

586
00:30:58,390 --> 00:30:59,823
How do you get this little queue argument?
怎样传入这个队列参数？

587
00:30:59,825 --> 00:31:02,993
Well, for the main queue, you call this function,
对于主队列来说，可以通过调用

588
00:31:02,995 --> 00:31:05,963
dispatch_get_main_queue. Now, you might ask,
dispatch_get_main_queue 来获得. 你或许会问，

589
00:31:05,965 --> 00:31:10,100
why is all these underbars and why does this look like this?
为什么这么多下划线，为什么这个方法长这样？

590
00:31:10,102 --> 00:31:15,339
This is basically a CAPI, okay, from iOS before Swift,
因为这是基于 CAPI 的，属于 iOS，而不是 Swift 的语法，

591
00:31:15,341 --> 00:31:18,008
and so it comes into swift looking like a CAPI.
所以这使得 Swift 看起来像 CAPI 一样.

592
00:31:18,010 --> 00:31:21,011
These are Swift, these are just Swift global functions.
在 Swift 中，这是个全局方法.

593
00:31:21,013 --> 00:31:23,413
But the reason this is not object oriented, for
它不是面向对象的，因为

594
00:31:23,415 --> 00:31:26,083
example is because this is a CAPI.
它是 CAPI.

595
00:31:26,085 --> 00:31:28,852
This, this is called grand central dispatch actually,
实际上，它被称为 GCD（大中枢派发）

596
00:31:28,854 --> 00:31:30,454
that's why they all start with dispatch,
所以这个方法以 dispatch 开头，

597
00:31:30,456 --> 00:31:33,290
all this multithreading stuff, and that's why it looks like
这就是为什么，所有这类多线程接口，都和这个类似.

598
00:31:33,292 --> 00:31:37,094
this. I'm gonna show you the object-oriented way to do
之后我会介绍怎么用面向对象的方式使用

599
00:31:37,096 --> 00:31:40,764
this in a minute, but actually we're gonna end up using these
这些接口，在此之前，你还会继续

600
00:31:40,766 --> 00:31:44,768
C-like ones more often, all right? So, again, all UI stuff
使用 C 语言的风格的接口. 再次强调，所有 UI 的操作

601
00:31:44,770 --> 00:31:49,039
have to be on this main queue. It's a serial queue, okay, so
都必须在主队列中进行. 这是个串行队列，

602
00:31:49,041 --> 00:31:51,608
nothing happens concurrently on this queue,
所以这个队列中不可能有并行的操作出现，

603
00:31:51,610 --> 00:31:55,112
things happen in order in the order they go in, okay?
入队是什么顺序，出队就是什么顺序，有问题吗？

604
00:31:55,114 --> 00:31:57,381
And, but all time-consuming stuff,
所有耗时的操作，

605
00:31:57,383 --> 00:31:59,750
okay, or even worse stuff that might block,
或其他耗资源的操作，都可能造成阻塞，

606
00:31:59,752 --> 00:32:02,786
like you're going out to the network to get an image,
就像网络请求图片这类的操作，

607
00:32:02,788 --> 00:32:05,555
like we are doing where that block's waiting for
或者其他因等待网络响应，

608
00:32:05,557 --> 00:32:07,958
the Web server on the other side to respond,
而导致阻塞的操作，

609
00:32:07,960 --> 00:32:10,794
all that wants to happen off the main queue.
这些操作，都不应该出现在主队列中.

610
00:32:10,796 --> 00:32:15,032
Now you still dispatch to that queue using dispatch_async.
目前我们在使用 dispatch_async 来派发队列.

611
00:32:15,034 --> 00:32:17,367
You go down here and you say look at the bottom,
看到讲义的底部，

612
00:32:17,369 --> 00:32:20,170
it says dispatc_async, not the main queue in here.
参数这里写到，不一定非要传入主队列.

613
00:32:20,172 --> 00:32:22,973
And I'll talk about where you get that queue in a second.
之后会讲到如何获得其他队列.

614
00:32:22,975 --> 00:32:24,007
And then open curly brace,
接着，代码包含在大括号中，

615
00:32:24,009 --> 00:32:27,644
so this is a closure, inside that closure you do the non-UI
所以这是一个闭包，在闭包中，执行的是和 UI 无关的

616
00:32:27,646 --> 00:32:31,081
thing that takes a long time or blocks. And then still
操作，它可能会花很长时间，或者发生阻塞. 接着又是一个

617
00:32:31,083 --> 00:32:35,485
inside this closure, you dispatch_async again. This
闭包，再次 dispatch_async. 这次

618
00:32:35,487 --> 00:32:39,990
time back to the main queue to do the UI stuff that you need,
回到了主队列中，处理和 UI 相关的操作，

619
00:32:39,992 --> 00:32:43,160
maybe that the image you got from doing this, you now put
可能是你请求完了图片，需要

620
00:32:43,162 --> 00:32:47,064
this in the UI here. So look how I'm dispatching within
扔到 UI 上进行显示. 所以来看看如何通过闭包

621
00:32:47,066 --> 00:32:50,567
a closure. So can you imagine this outer closure
来派发它们. 你能想象外部闭包

622
00:32:50,569 --> 00:32:53,770
is off running on some other thread in some other queue and
在其他队列的其他线程上运行，

623
00:32:53,772 --> 00:32:57,908
in the middle of it, it puts a block of code,
然后在其中，又有一个代码块，

624
00:32:57,910 --> 00:32:58,508
this block right here,
就是这个代码块，

625
00:32:58,510 --> 00:33:02,279
this closure. It puts it back on the main queue, this one
这个闭包. 又回到了主队列，

626
00:33:02,281 --> 00:33:05,315
continues to run after that in fact dispatc_async,
继续通过 dispatch_async 方法执行操作，

627
00:33:05,317 --> 00:33:08,418
that function always returns immediately. Because all it
这个方法会立即返回. 因为它是将任务

628
00:33:08,420 --> 00:33:11,655
does is put things on queues, it doesn't actually execute
扔到队列中，而没有真正执行

629
00:33:11,657 --> 00:33:13,490
any of the code inside the block.
代码块中的代码.

630
00:33:13,492 --> 00:33:16,827
It just puts that block of code onto the queue. Okay, and
只是将代码块扔到了队列中. 

631
00:33:16,829 --> 00:33:20,397
then this outer closure just happily runs to completion and
接着，这个外部闭包就

632
00:33:20,399 --> 00:33:23,500
it's done. Meanwhile, that inner block has been posted
执行完了. 与此同时，内部闭包也扔到了

633
00:33:23,502 --> 00:33:24,868
on the main queue and it's just waiting for
主队列中，等待

634
00:33:24,870 --> 00:33:27,637
the main queue, for it to be first in line and
主队列执行. 排到主队列中，

635
00:33:27,639 --> 00:33:28,405
for the main queue to be quiet, and
当主队列空闲下来，

636
00:33:28,407 --> 00:33:33,143
then it'll pick it up and run it. You got it? So this is why
便会出队并执行. 这就是为什么

637
00:33:33,145 --> 00:33:36,680
we use the C function notation because it reads really cool,
我们会用 C 函数，因为看起来真的挺酷的.

638
00:33:36,682 --> 00:33:39,816
okay? Dispatch off the queue this, then dispatch the main
先派发这个队列，然后派发

639
00:33:39,818 --> 00:33:44,087
queue this, okay? It reads very clearly to the person
主队列. 很容易让阅读代码的人

640
00:33:44,089 --> 00:33:46,790
who's reading your code what you intend. Okay, but
明白你的意图. 但是

641
00:33:46,792 --> 00:33:49,192
you do have to remember that this is async,
注意这些都是异步的，

642
00:33:49,194 --> 00:33:53,163
it's out of sync. Just because you say to execute this code,
不是同步的. 因为我们并不需要显性调用这些代码，

643
00:33:53,165 --> 00:33:53,997
it's not gonna happen right away.
这些代码不会立刻执行.

644
00:33:53,999 --> 00:33:56,099
It's just being put on that queue, it'll happen sometime
只是将它们加入到队列中，它们会在

645
00:33:56,101 --> 00:34:00,037
in the future when that queue is ready, okay? When it rises
队列空闲下来的时候自己执行. 当它们是队列

646
00:34:00,039 --> 00:34:04,975
to the top of that queue and the main queue is quiet, okay?
的队首元素，并且主队列闲下来的时候，就会执行.

647
00:34:04,977 --> 00:34:08,111
So how do we get these not the main queue queues?
那么，怎么获得除了主队列以外的队列呢？

648
00:34:08,113 --> 00:34:10,313
Okay, that we want to run something else on.
比如我们想要执行其他的一些操作.

649
00:34:10,315 --> 00:34:11,415
Well there's really two ways to do it.
这有两种方式可用.

650
00:34:11,417 --> 00:34:15,552
The most common way is to use one of the concurrent queues
最常见的直接使用系统提供的

651
00:34:15,554 --> 00:34:18,121
provided by the system, okay? Now these
并行队列. 这四种队列

652
00:34:18,123 --> 00:34:21,758
queues provided by the system there's four of them, okay?
就是系统提供的.

653
00:34:21,760 --> 00:34:25,295
They each have what's called a quality of service and
它们有着不同的优先级的服务，

654
00:34:25,297 --> 00:34:28,165
the quality of service is really how
服务的优先级其实就是

655
00:34:28,167 --> 00:34:31,668
much attention the system gives to them.
系统会给予多少的关注度.

656
00:34:31,670 --> 00:34:34,304
You can think of it as their priority. High-priority queues
你可以顺着优先级来认识它们. 高优先级队列

657
00:34:34,306 --> 00:34:37,174
get a high quality of service. They get serviced a lot, okay?
拥有最高优先级的服务. 它们能获得较多的服务.

658
00:34:37,176 --> 00:34:41,111
But it's not purely that, but it's generally that. So
但也不是绝对的，只是大致上来说而已.

659
00:34:41,113 --> 00:34:43,513
what are the four qualities of service here?
来看看这四种优先级的服务吧.

660
00:34:43,515 --> 00:34:46,817
One is USER_INTERACTIVE. So, you can get a queue, you
一种是 USER_INTERACTIVE. 所以，你可以通过调用

661
00:34:46,819 --> 00:34:49,753
can call this dispatch, get global queue right here. And
get_global_queue 方法来获得一个队列.

662
00:34:49,755 --> 00:34:52,589
you can say give me the user interactive queue. Again, it's
然后给它 USER_INTERACTIVE 优先级. 这是个

663
00:34:52,591 --> 00:34:54,925
a concurrent queue, so it's doing things concurrently,
并行队列，所以会并行处理操作，

664
00:34:54,927 --> 00:34:58,495
it's not serial. And user interactive means
这就不像串行了. USER_INTERACTIVE 意味着

665
00:34:58,497 --> 00:35:01,398
the user just asked to do something.
这是用户要求处理的事情.

666
00:35:01,400 --> 00:35:03,066
It's gonna take a little bit of time,
可能会花一些时间，

667
00:35:03,068 --> 00:35:04,801
so I don't want to do it on the main queue,
虽然我不想再主队列中进行处理，

668
00:35:04,803 --> 00:35:07,604
but I need this done as soon as possible because the user
但是我仍然希望能进行执行，毕竟这是用户

669
00:35:07,606 --> 00:35:09,673
is interacting with me right now, okay?
希望立马响应的操作.

670
00:35:09,675 --> 00:35:11,641
So, this is very high priority, but
所以它拥有最高优先级，

671
00:35:11,643 --> 00:35:15,345
lower priority than the main queue, okay? So, this might be
但这仍然要比主队列的优先级低. 这可能是

672
00:35:15,347 --> 00:35:18,081
something where the user is dragging with their finger,
用户在拖拽手指时，

673
00:35:18,083 --> 00:35:21,218
and you're having to calculate something to make the image
你需要同时计算一些数据并

674
00:35:21,220 --> 00:35:23,220
that's pretty intensive, time wise, and so
立即给出反馈，这时就应该将任务扔到

675
00:35:23,222 --> 00:35:26,089
you put it off on the thread. The user continues to drag,
这种队列中. 用户继续手指继续拖拽，

676
00:35:26,091 --> 00:35:27,390
they're not seeing the result and
但是没有看到数据显示，

677
00:35:27,392 --> 00:35:28,558
then the result comes back in and
等数据计算完成时，

678
00:35:28,560 --> 00:35:30,393
then the user gets to see the result. So
用户才能看到数据. 所以，

679
00:35:30,395 --> 00:35:32,362
the results a little bit behind their finger,
数据会比用户的手势慢一步，

680
00:35:32,364 --> 00:35:33,196
because it takes so much time, but
因为计算会花一些时间，

681
00:35:33,198 --> 00:35:35,799
at least as their finger tracks the main queue is still
但至少主线程一直在监听

682
00:35:35,801 --> 00:35:39,870
listening to their finger, okay, and responding, okay?
手指的轨迹，并且响应还是有的，

683
00:35:39,872 --> 00:35:42,005
So that's what USE_INTERACTIVE is for.
这就是 USER_INTERACTIVE 优先级.

684
00:35:42,007 --> 00:35:45,675
USE_INITIATED means the user just asked me to do this, but
USE_INITIATED 意思是，用户让我处理这个，但是不需要在

685
00:35:45,677 --> 00:35:48,812
it's not in the middle of an interactive event so, you can
用户交互的时候去处理，所以允许事件

686
00:35:48,814 --> 00:35:51,181
take a little bit of time but get back to me right away,
等待一些事件，但一旦处理完一定要有反馈

687
00:35:51,183 --> 00:35:53,950
cuz the user just asked for this, right now, okay?
因为这是用户要求处理的

688
00:35:53,952 --> 00:35:58,255
So, that's lower priority, than an interactive thing.
所以，它的优先级要比交互事件低一等

689
00:35:58,257 --> 00:36:02,626
UTILITY is something that usually runs in the background
UTILITY 一般用于在后台处理

690
00:36:02,628 --> 00:36:06,796
for a long time, okay? Maybe it's fetching data.
一些耗时操作，比如获取数据什么的.

691
00:36:06,798 --> 00:36:09,633
It's cleaning up some database somewhere. It's doing
也可以用于清理数据库，或者

692
00:36:09,635 --> 00:36:12,569
something that the user didn't ask to do, but that needs to
处理一些程序必须要处理，

693
00:36:12,571 --> 00:36:15,305
be done for this program. It's that kind of thing. And
而用户又没有要求处理的事件. 大致就是这一类事件. 

694
00:36:15,307 --> 00:36:17,941
then BACKGROUND is even lower priority. This is the kind of
BACKGROUND 的优先级最低. 一般将一些可

695
00:36:17,943 --> 00:36:22,078
thing well it could run today or tomorrow. But you know,
今天，可明天处理的事件加到里面. 也就是，

696
00:36:22,080 --> 00:36:24,247
it's really not something that I need done right away,
没必要立马处理，

697
00:36:24,249 --> 00:36:26,516
I don't really care. So, it's kind of just a,
不需要过于关注的事件. 就好比是，

698
00:36:26,518 --> 00:36:28,318
something that runs along in the background.
在后台默默执行的事件. 

699
00:36:28,320 --> 00:36:30,253
It's only gonna happen when things are really quiet,
在没有其他事件需要占用资源的时候，

700
00:36:30,255 --> 00:36:34,991
when nobody wants any other service, okay? So, you get one
它才执行. 到此，你就已经学习了

701
00:36:34,993 --> 00:36:37,594
of these four queues by saying dispatch_get_global_queue,
dispatch_get_global_queue 包含的四种优先级. 

702
00:36:37,596 --> 00:36:40,430
you specify which one you want. Then this has this
可根据需要选择. 除此之外，

703
00:36:40,432 --> 00:36:44,768
extra argument ,0 which is reserved for future use, so
还有一个参数 0，这将在之后用到，

704
00:36:44,770 --> 00:36:45,602
you just always put ,0 there.
现在就简单的传 0 就可以了.

705
00:36:45,604 --> 00:36:48,505
And that's gonna give you back a queue, a dispatch_queue_t
这样函数就会返回 dispatch_queue_t 类型的队列，

706
00:36:48,507 --> 00:36:51,942
that you can then use as your first argument to dispatch
它可以作为 dispatch_async 的第一个参数.

707
00:36:51,944 --> 00:36:55,645
async, okay. So these are the, this is the cues,
那么，这就是，

708
00:36:55,647 --> 00:36:57,514
these are the cues you're most often going to
这就是在你要处理后台事件时，

709
00:36:57,516 --> 00:37:00,383
put this work that needs to be done in the background onto.
最为常用的队列了.

710
00:37:00,385 --> 00:37:03,720
Now, its also possible for you to create your own
当然，你也可以创建自己的

711
00:37:03,722 --> 00:37:07,023
serial queue. You call dispatch_queue_create.
串行队列. 通过调用 dispatch_queue_create 函数，

712
00:37:07,025 --> 00:37:09,626
You give it a name. This can be any name you want, okay?
并给队列一个名字，任何名字都可以，

713
00:37:09,628 --> 00:37:12,028
This is usually just so you can see it in the debugger,
这在调试的时候经常看到，

714
00:37:12,030 --> 00:37:14,297
okay, this name is gonna appear in the debugger.
队列名称会出现在调试界面中.

715
00:37:14,299 --> 00:37:16,366
And then you say DISPATC_QUEUE_SERIAL,
第二个参数是 DISPATC_QUEUE_SERIAL，

716
00:37:16,368 --> 00:37:17,500
saying you want a serial queue.
表示你需要创建串行队列.

717
00:37:17,502 --> 00:37:20,737
Now you will get a serial queue of your own.
这样就能获得一个自己的串行队列了.

718
00:37:20,739 --> 00:37:22,672
And it's gonna be a pretty high priority queue,
这是一个优先级相当高的队列，

719
00:37:22,674 --> 00:37:25,742
nothing like the main queue, but pretty high priority.
虽然不像主队列那么高，但也算是万人之上了.

720
00:37:25,744 --> 00:37:27,644
Why would you ever want a serial queue?
什么时候需要创建串行队列呢？

721
00:37:27,646 --> 00:37:31,581
Let's say you had a big table that you wanna download
假设你有一个长长的列表，想要下载

722
00:37:31,583 --> 00:37:34,351
a thousand images to put in that table.
一千张图片扔到列表中

723
00:37:34,353 --> 00:37:37,754
Small little images, okay? Well you could do it on
都是些小图标. 你可以

724
00:37:37,756 --> 00:37:40,290
one of these user initiated queues or something like that.
在 USER_INITIATED 队列中或者其他队列中下载.

725
00:37:40,292 --> 00:37:42,225
But it's gonna fork off a whole bunch of threads and
但是这样系统就会创建一大串线程，

726
00:37:42,227 --> 00:37:45,128
try to download as many as it can concurrently.
而且尽可能多的进行并发下载.

727
00:37:45,130 --> 00:37:46,663
Open a whole bunch of network connections.
同时发起一堆网络请求.

728
00:37:46,665 --> 00:37:50,800
Whereas if you do is serially it will do it one by one,
但如果你在串行队列中处理，就会一个一个按秩序下载，

729
00:37:50,802 --> 00:37:53,837
okay? So it kind of throttles, it's a throttling,
就像是限流的阀门，

730
00:37:53,839 --> 00:37:55,872
a way of throttling your access to the network,
有限制的去访问网络.

731
00:37:55,874 --> 00:37:59,109
all right? You usually don't need this.
不过通常不需要这个.

732
00:37:59,111 --> 00:38:02,212
These are usually what you're gonna use for that not main
这些通常会在其他队列中处理，而不是主队列.

733
00:38:02,214 --> 00:38:06,449
queue queue, okay? Now, we're only seeing the absolute
到此，你已学习了多线程必备的一些知识，

734
00:38:06,451 --> 00:38:09,219
tip of the iceberg on multithreading here,
当然这只是冰山一角.

735
00:38:09,221 --> 00:38:13,323
okay? There's a lot more to GCD, Grand Central Dispatch.
更多关于 GCD，Grand Central Dispatch 的内容，

736
00:38:13,325 --> 00:38:14,557
You can look in the documentation for
可以查看文档，

737
00:38:14,559 --> 00:38:16,660
all the functions that start with dispatch underbar and
所有方法都以 dispatch_ 开头，

738
00:38:16,662 --> 00:38:20,263
you'll get an idea, there's at least a couple dozen in there.
至少有一打这样的方法.

739
00:38:20,265 --> 00:38:24,034
I don't have time to cover it in this class.
我没办法在课堂上依次为大家介绍.

740
00:38:24,036 --> 00:38:24,100
You won't need it,
其他方法你也不需要，

741
00:38:24,102 --> 00:38:26,102
you won't need anything more than I just showed you for
除了我介绍给大家的这些方法外，你暂时还用不到别的

742
00:38:26,104 --> 00:38:28,371
the work that you're gonna be doing in your assignments.
包括课后作业也不会用到.

743
00:38:28,373 --> 00:38:31,007
In your final project, you probably also won't need
甚至是最终考核项目，你都可能用不上

744
00:38:31,009 --> 00:38:33,910
anymore than that, but at least you know where to look,
别的方法，但至少要知道用的时候，

745
00:38:33,912 --> 00:38:38,214
if you might need more. There is an object-oriented
能在哪里查到. 这是面向对象的

746
00:38:38,216 --> 00:38:40,850
way of doing all this called, there's two classes,
调用方式，提供了两个类，

747
00:38:40,852 --> 00:38:43,853
NSOperationQueue, which is kind of like dispatch queues.
NSOperationQueue，和 dispatch queue 很像.

748
00:38:43,855 --> 00:38:47,824
And NSOperation, which is kinda like those closures,
还有 NSOperation，和闭包类似，

749
00:38:47,826 --> 00:38:52,929
right, those little functions. Why would you ever want this?
包含要处理的事件. 为什么我们需要这个两个类呢？

750
00:38:52,931 --> 00:38:56,132
These do have a little bit of extra functionality,
因为它们在 GCD 基础上，

751
00:38:56,134 --> 00:38:59,069
that they wrap from GCD, things like, hey,
还提供了一些额外的功能，比如，

752
00:38:59,071 --> 00:39:00,704
I have these two operations and
两个事件(operation)，

753
00:39:00,706 --> 00:39:04,441
this one depends on this one finishing, okay. And so
一个要在另一个结束之后发起.

754
00:39:04,443 --> 00:39:06,076
I'm gonna put them in a concurrent queue, but
把它们扔在并发队列中，

755
00:39:06,078 --> 00:39:08,845
don't let this other one go until the first one finishes,
也能保证一个在另一个结束之后发起.

756
00:39:08,847 --> 00:39:11,047
right. So dependencies, you can have dependencies and
这就是依赖，你能对事件添加依赖.

757
00:39:11,049 --> 00:39:14,417
things like that. We're not gonna talk about that.
课堂上不讲，

758
00:39:14,419 --> 00:39:16,553
You can look at the documentation if you want.
你可以在文档中看到.

759
00:39:16,555 --> 00:39:20,690
You can do, I think almost everything here with GCD.
我们需要的处理，GCD 已经足够了.

760
00:39:20,692 --> 00:39:23,259
This would be more if you actually are building
如果你是在创建一个

761
00:39:23,261 --> 00:39:26,029
something where there's queue are doing queues and
有很多队列，而且

762
00:39:26,031 --> 00:39:29,299
these operations are doing the actual calculation. Like as
operation 都在处理相关运算. 就像

763
00:39:29,301 --> 00:39:31,568
your model is doing, you're doing some scientific app and
建模一样，做一个科学相关的 app，

764
00:39:31,570 --> 00:39:33,803
it's actually doing all this complex calculation where
并且在处理一些非常复杂的计算，

765
00:39:33,805 --> 00:39:35,372
things depend on each other and all that stuff.
每个计算都相互依赖.

766
00:39:35,374 --> 00:39:38,441
And so it has a lot of queues and a lot of operations going.
这样，就需要很多队列和操作了.

767
00:39:38,443 --> 00:39:40,910
You wouldn't use it as much for things like, I'm fetching
也就这个时候，你需要使用到依赖，如果只是

768
00:39:40,912 --> 00:39:42,879
something from the network and I need to put it in the UI,
需要从网络上拉取数据，然后在 UI 上展示，

769
00:39:42,881 --> 00:39:45,181
and I want that fetched to happen in another queue.
即使想要在其他队列中发起请求，

770
00:39:45,183 --> 00:39:47,317
That kind of stuff you're just going to use the dispatch
dispatch_ 相关方法已经够用了.

771
00:39:47,319 --> 00:39:53,156
underbar, okay. Now, in addition to dispatch underbar,
作为 dispatch_ 的补充，

772
00:39:53,158 --> 00:39:55,625
you have to understand multithreading from
你还需要从 iOS 的 API 中

773
00:39:55,627 --> 00:39:57,827
the perspective of how iOS's API uses it.
理解多线程该如何使用.

774
00:39:57,829 --> 00:40:00,997
Because there are plenty of methods all throughout
因为关于异步线程的方法，

775
00:40:00,999 --> 00:40:05,168
iOS that do what they do asynchronously, using threads.
实在是太多了.

776
00:40:05,170 --> 00:40:08,438
Okay? And the way you see this in the API, is that one of
你在看 API 的时候，其中一个

777
00:40:08,440 --> 00:40:11,941
the arguments to these methods is a block, is a closure,
参数是 block，一个闭包，

778
00:40:11,943 --> 00:40:14,477
right? It's gonna be a closure you provide, and
闭包内容由你提供，

779
00:40:14,479 --> 00:40:16,980
the documentation for that function will say your
文档的解释是，你的闭包

780
00:40:16,982 --> 00:40:21,084
closure's executed off the main cue, asynchronously.
会异步的在主队中执行.

781
00:40:21,086 --> 00:40:23,753
So what kind of methods are we talking about here that do
这就是能解决我们之前问题的方法.

782
00:40:23,755 --> 00:40:27,690
that? Here's one that goes and fetches a URL. Okay,
可以用它来拉取网络数据.

783
00:40:27,692 --> 00:40:30,794
from the internet. Downloads it from the internet. And
进行网络数据下载.

784
00:40:30,796 --> 00:40:32,595
when it, and it does it asynchronously obviously.
它会在异步中处理.

785
00:40:32,597 --> 00:40:34,798
You wouldn't wanna block the main queue waiting for
你也不想要它因为加载 url，而阻塞主队列吧.

786
00:40:34,800 --> 00:40:37,233
this URL to load. And when it comes back,
在响应回来后，

787
00:40:37,235 --> 00:40:39,936
it calls this closure right here, okay? Now
它救护调用这个闭包.

788
00:40:39,938 --> 00:40:44,040
inside this closure, you might want to do some UI things.
在这个闭包中，你就可以做一些 UI 操作了.

789
00:40:44,042 --> 00:40:46,543
Like maybe you downloaded an image and you wanna put it.
比如显示刚下载完成的图片.

790
00:40:46,545 --> 00:40:49,078
But you can't put that code right inside here.
但是你不能直接将 UI 代码写在这，

791
00:40:49,080 --> 00:40:52,015
Because this closure is executed on a different
因为这个闭包会在

792
00:40:52,017 --> 00:40:54,818
thread and on a different queue than the main queue. So
另一个队列的线程中执行，而不是在主队列中执行. 所以

793
00:40:54,820 --> 00:40:56,886
what you would have to do in here is the same thing
这里你还需要

794
00:40:56,888 --> 00:40:57,720
you have to do with the dispatch_async,
像之前创建 dispatch_async 一样，

795
00:40:57,722 --> 00:41:03,560
which is you have to wrap dispatc_async ge_mai_queue
用一个主队列的异步线程去包裹它.

796
00:41:03,562 --> 00:41:07,464
around it, okay? So here's the method. This is an iOS method
就像这样写. 这是个 iOS 的

797
00:41:07,466 --> 00:41:10,333
downloadTaskWithRequest. It takes this last argument,
downloadTaskWithRequest 方法. 最后一个参数，

798
00:41:10,335 --> 00:41:12,836
which is a closure. And inside there you're gonna have to
是一个闭包. 在闭包中，

799
00:41:12,838 --> 00:41:15,572
do this dispatch to the main queue. Because if you wanna do
你需要回到主队列. 因为你要处理

800
00:41:15,574 --> 00:41:18,107
something to the UI, because this is not happening,
UI 相关操作，就不能直接写，

801
00:41:18,109 --> 00:41:21,911
this closure will not be executed on the main queue.
这个闭包不会在主队列中执行.

802
00:41:22,047 --> 00:41:25,982
Got it? So we will talk a little bit about, you're just
明白吗？所以建议大家

803
00:41:25,984 --> 00:41:29,919
gonna run into occasional iOS APIs that take these closures,
可以查查 iOS API 中，异步操作时，

804
00:41:29,921 --> 00:41:32,455
and they're asynchronous. And you just have to know that if
关于这个闭包的描述. 你需要知道，要处理任何

805
00:41:32,457 --> 00:41:33,957
you wanna do anything in the UI, you're gonna have
与 UI 相关的操作，都必须要

806
00:41:33,959 --> 00:41:38,628
to dispatch async back to the main queue. All right, so
先回到主队列. 行，接下来

807
00:41:38,630 --> 00:41:41,364
let's do a demo of this where let's fix Cassini.
我们来完善 Cassini demo 中的问题.

808
00:41:41,366 --> 00:41:44,934
Okay, let's make Cassini so that it's UI's always
优化一下 Cassini 的 UI，

809
00:41:44,936 --> 00:41:49,606
responsive even while it's off downloading these things.
使之在有下载任务的时候，也能及时响应事件.

810
00:41:49,608 --> 00:41:53,376
All right lets go over here.
那么从这里开始吧.

811
00:41:53,378 --> 00:41:55,445
Okay, all this is gonna be, all this code that we're going
先处理这些，这些在 ImageViewController

812
00:41:55,447 --> 00:41:57,514
to have to do is going to be in our ImageViewController.
中的代码.

813
00:41:57,516 --> 00:41:59,916
We're going to make our ImageViewController, so
先要将 ImageViewController 改为

814
00:41:59,918 --> 00:42:02,952
that it is asynchronous, right? That it can load things
异步处理，这样就能异步

815
00:42:02,954 --> 00:42:05,522
asynchronously. Before I do that actually though,
加载数据. 在实际操作之前，

816
00:42:05,524 --> 00:42:07,524
I wanna talk one other thing we should be doing here,
我还要讲到一件事，

817
00:42:07,526 --> 00:42:08,958
probably, in ImageViewController.
需要在 ImageViewController 中注意的事.

818
00:42:08,960 --> 00:42:12,495
Notice that if someone sets our model, we immediately go
注意这里有一段设置模型的代码，我们在里面

819
00:42:12,497 --> 00:42:17,133
off and fetch it, okay? Now what if we never appeared on
获取数据. 但如果我们从未将它展示在

820
00:42:17,135 --> 00:42:21,437
screen? Okay, what if this or something that's in a,
屏幕上呢？如果这是个，

821
00:42:21,439 --> 00:42:24,207
gonna be in a navigation controller, it got created,
这是个 navigation controller 之类的，虽然创建了，

822
00:42:24,209 --> 00:42:27,710
but no one ever clicked to cause it to happen on screen,
并且进行了模型设置，

823
00:42:27,712 --> 00:42:28,311
but someone set our model.
但是从来没有经过点击事件展示到屏幕上.

824
00:42:28,313 --> 00:42:30,980
Then this wouldn't happen in Cassini, this app, but imagine
虽然这问题不会出现在 Cassini 中，但是要小心在

825
00:42:30,982 --> 00:42:35,418
an app where you've got this image MVC and some incentive.
其他 app 中重用这个 image 的 MVC 结构或逻辑的情况.

826
00:42:35,420 --> 00:42:37,186
Really we really wouldn't want to do this
千万不要出现这种额外的资源消耗，

827
00:42:37,188 --> 00:42:39,789
fetch cuz it could be very expensive as we've seen,
这种资源占用非常昂贵.

828
00:42:39,791 --> 00:42:40,623
right? It goes on the network,
明白吗？这需要用到网络，

829
00:42:40,625 --> 00:42:42,292
it's pulling down this thing if I'm paying for
要从网络上拉去数据，而如果我允许

830
00:42:42,294 --> 00:42:44,928
cellular data, it's costing me money! Okay,
蜂窝数据，这会产生费用的！

831
00:42:44,930 --> 00:42:47,931
to get that Cassini image, so I probably don't want to do
所以，除非是在显示到屏幕上时，

832
00:42:47,933 --> 00:42:51,968
this fetch image unless I'm on screen. If I'm on screen,
我才会去获取 Cassini 的图片数据. 只有在屏幕上时，

833
00:42:51,970 --> 00:42:55,004
I definitely want to do this. So here I'm going to say how
我才需要这样做. 那么，如何判断是否在

834
00:42:55,006 --> 00:42:58,341
can I tell if I'm on screen? If my view, okay,
屏幕上呢？如果这个 view，

835
00:42:58,343 --> 00:43:03,913
this is my MVC's view the top level, if it's window
即 MVC 结构中最顶层的 view，它的 window 

836
00:43:03,915 --> 00:43:08,618
is not nil. Okay, that's a pretty reliable way to tell,
不是 nil. 则说明视图在屏幕上，

837
00:43:08,620 --> 00:43:12,989
sorry, that you are on screen, right? Because your view,
这种验证方式很靠谱. 因为你的 view，

838
00:43:12,991 --> 00:43:15,692
your mvc's view will not be in a window unless it's on
你的 mvc view 不在屏幕上，才获取不到 window.

839
00:43:15,694 --> 00:43:19,529
screen. Make sense? We haven't talked about window much.
明白吗？我们目前还没讲到太多 window 的知识.

840
00:43:19,531 --> 00:43:22,765
It's that UI Window class I told you that you really never
它就是之前我告诉你们的，

841
00:43:22,767 --> 00:43:23,299
use it, and you don't.
永远不要用，并且你们也没有用的那个 UIWindow 类.

842
00:43:23,301 --> 00:43:26,436
You're not going to send any messages to it here. But
这里不需要调 window 的方法，

843
00:43:26,438 --> 00:43:26,569
whether it's nil or
直接判断它是否是 nil，

844
00:43:26,571 --> 00:43:29,105
not will tell you whether your view is on screen.
就能告诉你 view 是否在屏幕上.

845
00:43:29,107 --> 00:43:32,342
Now what happens though if someone sets my image URL like
那么，现在如果有人在 prepareForSegue 或者

846
00:43:32,344 --> 00:43:36,713
in a prepare for segue and then I do go on screen later?
视图展示在屏幕上时，设置了图片 URL，

847
00:43:36,982 --> 00:43:39,349
Now I have to fetch that image, okay? Cuz now I
我就回去获取图片数据. 因为下一步肯定能

848
00:43:39,351 --> 00:43:41,918
am going to go on screen. So how can I find out in my view
展示到屏幕上. 那么如何得知 view controller 

849
00:43:41,920 --> 00:43:44,487
controller lifecycle that now I'm gonna go on screen,
生命周期中，何时展示到屏幕上呢？

850
00:43:44,489 --> 00:43:49,993
which method? Which method in my view controller lifecycle?
哪个方法？view controller 生命周期中的哪个方法？

851
00:43:49,995 --> 00:43:54,497
Do you remember? It called. I'll put it down here
还记得吗？它叫做...

852
00:43:54,499 --> 00:43:59,302
next to this viewDidLoad one. ViewWillAppear. Okay, so
和 viewDidLoad 写在一起吧. 叫做，viewWillAppear.

853
00:43:59,304 --> 00:44:02,071
viewWillAppear is sent to you when you're about to appear on
在即将展示到屏幕上时，会调用 viewWillAppear 方法.

854
00:44:02,073 --> 00:44:06,509
screen. Okay and we always do super.viewWillAppear in
对于 view controller 声明周期的方法，

855
00:44:06,511 --> 00:44:10,146
all these view controller life cycles, all right. So,
我们通常会先调用父类的方法，super.viewWillAppear.

856
00:44:10,148 --> 00:44:14,050
here I'm going to say if my image is nil,
在这里判断，如果 image 是 nil，

857
00:44:14,052 --> 00:44:19,255
then I better go fetch it, okay? So, this is one
那么就获取它，这样处理

858
00:44:19,257 --> 00:44:22,692
thing I've done to increase my performance a little bit. But
能提升一点点性能. 但是

859
00:44:22,694 --> 00:44:24,794
it's still not going to stop things from blocking,
依然没能解决阻塞问题，

860
00:44:24,796 --> 00:44:26,562
because as soon as viewWillAppear happens,
因为当 viewWillAppear 调用时，

861
00:44:26,564 --> 00:44:27,597
and I'm just about to go on screen,
并且视图在屏幕上，

862
00:44:27,599 --> 00:44:30,900
my whole app is going to freeze while I'm out fetching.
整个 app 都被阻塞了，需要去获取数据.

863
00:44:30,902 --> 00:44:32,268
Those big huge images, right?
去获取一张很大的图片.

864
00:44:32,270 --> 00:44:34,437
So I haven't really fixed the problem. I need multithreading
所以我们还没解决这个问题，我需要用到多线程.

865
00:44:34,439 --> 00:44:36,506
for that. But I just wanted to show you to be a little bit
我将会演示如何小心翼翼的

866
00:44:36,508 --> 00:44:40,009
careful about when you fire off an expensive operation.
开启这一昂贵操作的技能.

867
00:44:40,011 --> 00:44:42,178
That's what viewWillAppare, Appear is for.
这也是 viewWillAppear 的作用.

868
00:44:42,180 --> 00:44:44,080
That's really where you wanna fire off things like going
你需要在这里发起所有的操作，

869
00:44:44,082 --> 00:44:48,084
out on the network and stuff, okay? All right, so now let's
例如网络请求什么的. 那么现在就

870
00:44:48,086 --> 00:44:50,620
do our multi guiding and fix this. We're gonna do this here
遵循着多线程规则，来解决阻塞问题吧. 我们需要对

871
00:44:50,622 --> 00:44:53,389
in fetchImage. We're gonna make it so that fetchImage
fetchImage 进行处理. 我们需要使 fetchImage

872
00:44:53,391 --> 00:44:57,126
does the actual fetching in another thread. All right, so
真正的获取事件发生在另一个线程中. 

873
00:44:57,128 --> 00:45:00,997
how are we gonna do this? It's pretty simple actually.
那么怎么实现呢？其实很简单.

874
00:45:00,999 --> 00:45:05,968
We're just going to take this code right here which blocks.
只需要将这段代码，这个 block，

875
00:45:05,970 --> 00:45:07,937
This blocks the main queue while it goes out
这个 block 是在主线程进行

876
00:45:07,939 --> 00:45:10,640
on the network, to forget the contents of this URL.
网络请求来获取 url 内容的.

877
00:45:10,642 --> 00:45:13,843
And we're going to use the GCD to
我们使用 GCD 来

878
00:45:13,845 --> 00:45:16,846
put it on a different thread, okay? So I'm just going to
将操作扔到不同的线程中. 所以，代码应该是，

879
00:45:16,848 --> 00:45:21,718
say, dispatch, async, okay? Remember, dispatch async
dispatch_async，记得吗，dispatch_async

880
00:45:21,720 --> 00:45:26,122
takes two arguments. A queue and a block here, a closure or
有两个参数，一个队列和一个 block，即一个闭包或

881
00:45:26,124 --> 00:45:31,194
a function do that. So I'm going to put on one of those,
一个方法. 我准备将处理扔到

882
00:45:31,196 --> 00:45:34,497
concurrent cues. And I'm gonna put it on the one where
并行队列中. 优先级是

883
00:45:34,499 --> 00:45:36,733
the user initiated it but it's not interactive.
user initiated，而不是 interactive.

884
00:45:36,735 --> 00:45:38,634
The user's not in the middle of dragging or something.
因为处理中，用户不会进行拖拽等交互.

885
00:45:38,636 --> 00:45:40,536
They initiated it so it's pretty high priority and
initiated 的优先级已经很高了，

886
00:45:40,538 --> 00:45:45,208
so I get that by saying dispatch_get_global_queue and
调用 dispatch_get_global_queue 来获得队列，

887
00:45:45,210 --> 00:45:47,477
the one I want is
这个参数是

888
00:45:47,479 --> 00:45:54,083
QOS_CLASS_USE_INITIATED. This one right here, okay?
QOS_CLASS_USE_INITIATED. 第一个参数搞定，

889
00:45:54,085 --> 00:45:58,287
This flags is always zero, right? And now I have this
这个标识直接填 0. 接下来配置 block，

890
00:45:58,289 --> 00:46:00,423
block here, so I'm gonna double-click on that.
双击代码提示，

891
00:46:00,425 --> 00:46:00,957
It's really nice, by the way,
就自动补全了，另外，

892
00:46:00,959 --> 00:46:04,193
you can double-click on these things to expand the block.
除了能双击展开 block 以外，

893
00:46:04,195 --> 00:46:06,829
I'm gonna use the clay trailing,
我使用的的是尾闭包的形式，

894
00:46:06,831 --> 00:46:11,400
closure syntax here. Okay for my block, this block, you'll
完善闭包语法. 这里就是我的 block 了，

895
00:46:11,402 --> 00:46:13,836
notice it takes no arguments, returns no arguments.
你可以看到这个 block 没有参数，也没有返回值.

896
00:46:13,838 --> 00:46:18,941
I'm just going to put all this blocking junk inside here,
然后将这一大段 block 代码，扔到尾闭包中.

897
00:46:18,943 --> 00:46:23,012
okay. So this is going to fix my problem, okay.
这样就能解决我们的问题了.

898
00:46:23,014 --> 00:46:28,217
Except that it probably gonna make my app go all strange
不过这样写可能会导致 app 出现以下莫名其妙的问题，

899
00:46:28,219 --> 00:46:32,155
because I'm gonna be trying to do this inside
因为我在

900
00:46:32,157 --> 00:46:36,459
a non-main queue. All right, cuz this queue, this block
非主队列做了这个操作. 因为这个 block 

901
00:46:36,461 --> 00:46:40,329
right here is gonna be put on this queue, and so I can't do
会在这个队列中执行，所以我们不能在 block 里面

902
00:46:40,331 --> 00:46:43,933
this inside of here. Question? >> Can you explain
做这个操作. 什么问题？能讲一下

903
00:46:43,935 --> 00:46:44,867
the trailing, the plot,
尾闭包吗？

904
00:46:44,869 --> 00:46:47,804
the trailing plot where you added the parenthesis and
应该在哪添加括弧，它是怎样

905
00:46:47,806 --> 00:46:49,438
what it does? >> Yeah, okay, so
执行的？行，好的，

906
00:46:49,440 --> 00:46:55,511
this used to look like this. Okay, so this is normal.
闭包以前是长这样的，这是一个普通的闭包.

907
00:46:55,513 --> 00:46:57,947
I'm calling this function right here, okay? Sorry,
我在调用这个方法时，哦，不好意思，

908
00:46:57,949 --> 00:47:00,750
this function right here. Here is its first arguments,
这个方法. 这是第一个参数，

909
00:47:00,752 --> 00:47:05,388
see that? Here its second argument, okay.
这是第二个参数.

910
00:47:05,390 --> 00:47:09,158
If the sec, if the last argument of any function is
如果第二个参数，如果最后一个参数接收的是

911
00:47:09,160 --> 00:47:14,697
a closure, then you can put it outside of the parenthesis.
闭包，那么就可以将其写在参数列表以外.

912
00:47:14,699 --> 00:47:17,466
See this dispatch_async parentheses starts here? So
这个 dispatch_async 方法括号从这里开始，

913
00:47:17,468 --> 00:47:20,603
I just took this parentheses off of here and
我只是将这里的反括弧，

914
00:47:20,605 --> 00:47:26,475
I put it over here. Okay, so now this is the first
移到了这里. 所以，现在这里是函数的

915
00:47:26,477 --> 00:47:29,812
argument to this function, inside these parenthesis. And
第一个参数，在参数列表的括号内.

916
00:47:29,814 --> 00:47:33,149
here's the closure which is outside the parenthesis, okay.
而这个闭包，在括号外面.

917
00:47:33,151 --> 00:47:36,185
You definitely wanna get used to that cuz we're almost
这种写法你一定会熟悉的，因为之后我们

918
00:47:36,187 --> 00:47:39,155
always gonna do it that way. And when people design APIs
都会这样写. 当开发者在设计 API 的时候，

919
00:47:39,157 --> 00:47:41,390
they almost always put the closure at the end so
他们尽量将闭包扔到最后，这样

920
00:47:41,392 --> 00:47:44,560
people can do this. All right, so
使用者就可以用尾闭包了.

921
00:47:44,562 --> 00:47:45,595
what am I gonna do about this,
所以我也这样去使用它.

922
00:47:45,597 --> 00:47:49,332
okay? I need this to be back on the main queue. Well,
现在我需要回到主队列.

923
00:47:49,334 --> 00:47:52,902
very simple here. I'm just going to dispatch it back to
非常简单，只需要将它派发回

924
00:47:52,904 --> 00:47:57,707
the main queue. Now, another thing I'm gonna do here,
主队列即可. 除此之外，还有一件事需要处理，

925
00:47:57,709 --> 00:48:02,278
while I'm kinda at it is, let's get this NSData right
先这样，先将这里获取的 NSData 

926
00:48:02,280 --> 00:48:06,082
here. I'm gonna assign that to a local variable
使用临时变量接受一下，

927
00:48:06,084 --> 00:48:10,519
here called content of URL, okay? And then I'm gonna put,
叫 contentsOfURL，

928
00:48:10,521 --> 00:48:12,922
so that's gonna be happening in my other queue.
这一部分是发生在另一个队列中的.

929
00:48:12,924 --> 00:48:17,960
And then I'm gonna dispatch async back to the main queue,
然后，调用 dispatch_async 回到主队列，

930
00:48:17,962 --> 00:48:21,597
which I get by dispatch_get_main_queue.
传入 dispatch_get_main_queue.

931
00:48:21,599 --> 00:48:24,901
Okay, same exact thing here, okay, here's the block,
这个是一样的，这个 block，

932
00:48:24,903 --> 00:48:28,604
I'm gonna do the same thing. Click trailing, close your
和之前一样. 改为尾闭包，

933
00:48:28,606 --> 00:48:33,376
notation, and now I'm gonna put this inside here, okay.
然后将代码扔进去，

934
00:48:33,378 --> 00:48:37,413
But now the image data is this thing that I got right there,
现在 imageData 应该是这个，我将它放在这，

935
00:48:37,415 --> 00:48:41,317
so that's content of URL.
所以是 contentsOfURL.

936
00:48:41,319 --> 00:48:46,188
Okay, now this happening on the main queue, all is well.
现在，这就在主队列中执行了，全部搞定.

937
00:48:46,190 --> 00:48:50,459
This image=UIImage, the UI kit thing. This is a UI kit thing,
这个 image 是 UIImage，UIKit 中的那个. 这个 UIKit 元素，

938
00:48:50,461 --> 00:48:52,795
by the way, no, not actually because of the UIImage.
准确的说不是严格是，因为它是 UIImage，

939
00:48:52,797 --> 00:48:55,898
That is the one UI thing you can do on a different thread.
而 UIImage 可以在不同的线程中处理，

940
00:48:55,900 --> 00:48:58,367
But it's because when we say image= down here,
这只是进行了图片下载，

941
00:48:58,369 --> 00:49:01,904
it's gonna do something like imageview.image=new value.
因为我们之后要将 image 赋值给 imageView.image.

942
00:49:01,906 --> 00:49:03,439
Okay, well that's the UI kit right there, so
而 UIImageView 是 UIKit 元素，所以

943
00:49:03,441 --> 00:49:06,575
that has to be on the main thread. So that's why I have
必须要在主线程在中处理. 这才是我们要回到主线程的原因.

944
00:49:06,577 --> 00:49:08,878
to do that. Now notice we still have an error here.
注意我们这里还在报错.

945
00:49:08,880 --> 00:49:11,814
Anyone know what this error is? It's pointing right here.
有人知道这个错误原因吗？有人知道吗？

946
00:49:11,816 --> 00:49:17,987
What do you think it wants there? No idea?
知道编译器想要我们怎么做吗？没人知道？

947
00:49:21,059 --> 00:49:26,128
It wants self there, because this is a closure. Okay,
它想要加上 self，因为这是一个闭包，

948
00:49:26,130 --> 00:49:27,697
this is inside a closure. And remember,
这段代码在闭包中，记住，

949
00:49:27,699 --> 00:49:32,702
whenever we have a closure and we use a property on our
无论何时，在闭包中访问属性或成员变量，

950
00:49:32,704 --> 00:49:36,472
object, we need to put self in there to make it
都需要使用 self 调用，

951
00:49:36,474 --> 00:49:39,342
clear that we understand this is being captured and
以此指明变量值快照，

952
00:49:39,344 --> 00:49:44,480
kept in the heap. So as long as this closure right here,
并将它存到堆中. 所以，无论是这个闭包，

953
00:49:44,482 --> 00:49:46,749
which it's got this closure inside of it.
还是这个包含在闭包内的闭包，

954
00:49:46,751 --> 00:49:49,385
As long as this is out there fetching,
只要是在函数作用域外了，

955
00:49:49,387 --> 00:49:54,190
it's going to keep this view controller in the heap, okay?
都需要将 view controller 保存在堆上.

956
00:49:54,192 --> 00:49:58,194
Now if we wanted to here, we could do the week self thing
如果我们要在这里使用，还需要用 weak 修饰 self，

957
00:49:58,196 --> 00:50:02,398
and have week self question mark and that way if the image
防止在图片数据回来的时候，self 已经被释放，

958
00:50:02,400 --> 00:50:06,469
came back and our MVC had been thrown out of the heap,
导致 MVC 抛出的堆内存异常.

959
00:50:06,471 --> 00:50:09,405
it would be fine, we would just ignore it.
这样就能避免了，就能忽略掉异常了.

960
00:50:09,407 --> 00:50:11,841
Okay, but I'm pressed for time so I'm not gonna do that but
因为时间原因，我就不演示了，

961
00:50:11,843 --> 00:50:15,277
you could hopefully imagine doing that. Okay, so
不过你们应该能想象出来. 

962
00:50:15,279 --> 00:50:17,179
everyone see what we've done here?
每个人都能理解了吗？

963
00:50:17,181 --> 00:50:20,883
So that's really all we need to do. One thing that it's
这就是我们需要的全部处理. 对了，

964
00:50:20,885 --> 00:50:24,053
a little, now, I told you that multithreading, it's pretty
还有一小点，现在我讲解了多线程，

965
00:50:24,055 --> 00:50:26,522
easy to read this code and understand what's going on.
非常简单，一看代码就能明白.

966
00:50:26,524 --> 00:50:29,725
But you've got to think of the bigger picture of what's
但是你想想，如果是在用多线程

967
00:50:29,727 --> 00:50:32,962
happening with multithreading here. For example,
加载一张很大的图片呢，会怎样. 比如，

968
00:50:32,964 --> 00:50:37,500
what happens in Cassini if I click on the Cassini,
在点击 Cassini 按钮时，Cassini 会怎样，

969
00:50:37,502 --> 00:50:40,236
which is a kind of a small image, and
这还是张小图，

970
00:50:40,238 --> 00:50:43,305
then I change my mind and click on Earth.
如果我临时改变主意，点击了 Earch.

971
00:50:43,307 --> 00:50:48,377
Okay, so Cassini, which is small, comes back, okay?
现在，Cassini 这张小图加载完成，

972
00:50:48,379 --> 00:50:51,280
This code is gonna put Cassini on screen. But then the Earth
那么 Cassini 就会渲染在界面上，这时候，Earth 

973
00:50:51,282 --> 00:50:53,883
is gonna come back and this code's gonna put the Earth on
加载完了，Earth 就会覆盖在 Cassini 上，

974
00:50:53,885 --> 00:50:55,951
top of it, okay? So I'm gonna get this flashing thing,
所以就会导致 Cassini 图片闪一下，

975
00:50:55,953 --> 00:50:58,788
Cassini, Earth. Or worse, if I clicked Earth first and
接着显示 Earth. 更糟的是，如果我先点击的 Earth，

976
00:50:58,790 --> 00:51:01,057
then clicked Cassini, it would show Cassini and
之后再点击 Cassini，万一先展示 Cassini，

977
00:51:01,059 --> 00:51:03,359
then later Earth would come in and it would be showing Earth,
之后再展示 Earth，然后 Earth 就是最终渲染的图片，

978
00:51:03,361 --> 00:51:04,693
even though I clicked on Cassini.
即使我最后点击的是 Cassini.

979
00:51:04,695 --> 00:51:07,830
Okay, do you see the problem, is that I'm firing off these
能明白这个问题吗？我在不同的线程中，

980
00:51:07,832 --> 00:51:09,265
network things in other threads.
发起的网络请求，

981
00:51:09,267 --> 00:51:11,767
They're coming back at different times. So
他们的响应时间可能会不同.

982
00:51:11,769 --> 00:51:12,435
really I want to,
所以，

983
00:51:12,437 --> 00:51:14,870
If I'm gonna be a good programmer here,
如果我是一个优秀的开发者，

984
00:51:14,872 --> 00:51:16,172
multithreaded, I need to check and
在多线程中，我需要检查响应的

985
00:51:16,174 --> 00:51:19,208
make sure that the URL that I'm fetching,
URL，是否是我之前获取的那个，

986
00:51:19,210 --> 00:51:24,480
that's this URL right here, is still equal to the image URL
即这个 URL，是否匹配这个 imageURL.

987
00:51:24,482 --> 00:51:29,618
that I ask for. Okay, then I'll do this. If it's not,
如果匹配，才赋值. 如果不匹配，

988
00:51:29,620 --> 00:51:34,156
then maybe I could print something like ignored data
那么就输出 ignore data，

989
00:51:34,158 --> 00:51:39,061
returned from URL, and then we'll put the URL in here,
returned from URL，然后将 url 拼在后面.

990
00:51:39,063 --> 00:51:43,232
okay? And that needs self here, of course, cuz that's
这里也需要加上 self，毕竟

991
00:51:43,234 --> 00:51:47,002
inside this closure as well, all right? Everybody got that?
这也是在闭包中. 都懂了吗？

992
00:51:47,004 --> 00:51:50,439
So let's go ahead and run, see if this works. So
那我们来运行下，看看效果.

993
00:51:50,441 --> 00:51:54,110
what we should have now is a very responsive UI, okay,
所以，现在拿到的是一个丝滑的 UI，

994
00:51:54,112 --> 00:51:56,412
all the time, no matter what we click on, so let's try it.
整个程序都是，无论是点击哪个按钮，试试，

995
00:51:56,414 --> 00:51:59,482
Earth, Cassini, see I'm able to click on different things.
Earth，Cassini，看见了吗，都没有被阻塞.

996
00:51:59,484 --> 00:52:04,587
I can still rotate, okay. Whoops, wrong way around. And,
还可以进行旋转. 噢喔...旋转方式错了.

997
00:52:04,589 --> 00:52:09,125
the it's gonna pick whichever the last one that I asked for.
无论我最后请求的是哪个，

998
00:52:09,127 --> 00:52:11,060
It's still fetching right here. It's gonna eventually,
都会获取到争取的图片. 最终，

999
00:52:11,062 --> 00:52:17,633
hopefully, get one. And maybe it's even easier to see this,
都会获取到一张. 可能要等会才能请求完，

1000
00:52:17,635 --> 00:52:20,402
maybe. Let's stop this action, go look on our iPhone, cuz you
停止这个程序，重新跑在 iPhone 上看看，

1001
00:52:20,404 --> 00:52:23,172
can really see it happening on iPhone because when we click
因为这个过程在 iPhone 上更清晰，

1002
00:52:23,174 --> 00:52:26,142
on them, it actually segues and comes back.
它会有视图的转场效果.

1003
00:52:26,144 --> 00:52:31,881
So watch this. Are we running here?
来看看. 跑起来了吗？

1004
00:52:31,883 --> 00:52:37,887
Oops, no, we want iPhone.
哦，不对，我们需要的是 iPhone.

1005
00:52:40,491 --> 00:52:43,759
Okay, so we go back here. Now I click Cassini,
好了，回到这个界面，点击 Cassini，

1006
00:52:43,761 --> 00:52:46,228
it's loading it, but I can go back, okay.
程序正在加载，这时我点击返回，

1007
00:52:46,230 --> 00:52:48,197
While this is still loading, I can go back and
但其实加载还在继续，

1008
00:52:48,199 --> 00:52:51,634
change my mind because my UI is highly responsive,
我能临时改变主意，能点击返回，因为 UI 并未被阻塞，

1009
00:52:51,636 --> 00:52:53,636
even though it's loading those things in the background.
即使图片在后台加载.

1010
00:52:53,638 --> 00:52:56,705
When they eventually arrive, it's gonna put them in the UI,
当图片下载完成后，便会在 UI 上显示，

1011
00:52:56,707 --> 00:53:00,109
okay. But while they're out there fetching I can do things
但在下载过程中，

1012
00:53:00,111 --> 00:53:06,882
like go back in my navigation controller. Make sense,
我可以做其他的操作，比如点击返回按钮等。看吧，

1013
00:53:06,884 --> 00:53:13,522
see that? >> [INAUDIBLE]
没问题。[清不清楚]

1014
00:53:13,524 --> 00:53:14,056
>> What happens, what?
什么事？怎么？

1015
00:53:14,058 --> 00:53:14,857
>> [INAUDIBLE] Image each time
[听不清] 假设每次

1016
00:53:14,859 --> 00:53:17,560
you click out. >> So the question is, if I
都快速返回。那么，每次返回后，

1017
00:53:17,562 --> 00:53:20,596
click out, and then click back in, does it reload the image?
再点进去，会重新下载图片吗？

1018
00:53:20,598 --> 00:53:22,831
And the answer is absolutely, because when I click out,
答案显而易见，因为再返回后，

1019
00:53:22,833 --> 00:53:26,068
it throws that MVC out of the heap. Okay, it's gone.
MVC 的堆内存就被销毁了，也就不存在了。

1020
00:53:26,070 --> 00:53:28,103
Now actually, that MVC is not gonna immediately leave
但这次，MVC 却没有立即销毁，

1021
00:53:28,105 --> 00:53:30,773
the heap, cuz that closure that's doing the fetching is
因为闭包还在执行下载，

1022
00:53:30,775 --> 00:53:33,108
still holding it in the heap. But once that fetch comes
持有了该内存。当数据下载完成后，

1023
00:53:33,110 --> 00:53:36,779
back, then it'll leave the heap and the image with it. So
堆内存便销毁了，下载的图片也是。

1024
00:53:36,781 --> 00:53:40,583
yeah, every time we're re-fetching, okay?
所以，每次都是重新下载的，明白？

1025
00:53:41,552 --> 00:53:41,684
So see how we built this nice responsive UI right now, okay?
这就是我们讲到的快速响应 UI。

1026
00:53:41,686 --> 00:53:45,221
Everybody got that?
大家都明白吗？

1027
00:53:45,223 --> 00:53:48,090
Even though it's still taking a long time to fetch things,
即使数据下载依然需要很长时间，

1028
00:53:48,092 --> 00:53:51,493
we can still navigate. Now, what's a little weird about
但并不影响跳转。但是，UI 还有些

1029
00:53:51,495 --> 00:53:54,330
this UI, though, is that while it's fetching,
不足，在数据下载时，

1030
00:53:54,332 --> 00:53:57,633
like when I'm here, it's not clear what's going on.
比如这个界面，并不知道它在处理什么。

1031
00:53:57,635 --> 00:53:59,168
It looks like there's just no Earth image,
这里好像并没有 Earth 的图片，

1032
00:53:59,170 --> 00:54:02,171
I guess. I don't know, I guess not, I don't see it. Wouldn't
我也不知道，可能是吧，什么都看不见。如果

1033
00:54:02,173 --> 00:54:04,840
it be cool if we could give some feedback to the user?
能给用户一个标识不是更好吗？

1034
00:54:04,842 --> 00:54:08,544
Hey, I'm working on it, okay, this image is big.
Hey，我正在努力加载呢，图片太大了。

1035
00:54:08,546 --> 00:54:09,545
All right, and we can do that.
是的，我们可以处理。

1036
00:54:09,547 --> 00:54:12,414
And the cool way to do that is with a little spinner, okay,
可以在这里加个指示器，

1037
00:54:12,416 --> 00:54:15,651
a little animating. You see them all in apps little thing
一个小动画。在很多 app 中都能看到

1038
00:54:15,653 --> 00:54:17,886
that spins around basically telling him yeah, yeah,
指示器，告知系统收到了交互，

1039
00:54:17,888 --> 00:54:20,789
I know, I'm working on it. So let's put a spinner in there.
正在进行处理。那么，让我们在这里加上指示器吧。

1040
00:54:20,791 --> 00:54:24,059
Turns out to be really easy to put, do spinners in iOS.
在 iOS 中加指示器，真的非常简单。

1041
00:54:24,061 --> 00:54:26,395
We're just gonna go to the storyboard, okay.
打开 storyboard，

1042
00:54:26,397 --> 00:54:30,232
I'm gonna put the spinner here in this view. Now when I put
将指示器加到这个 view 中。但注意，

1043
00:54:30,234 --> 00:54:32,167
it in there, I'm gonna have to be very careful.
加进去要非常小心。

1044
00:54:32,169 --> 00:54:32,501
And this is a good chance for
正好给大家

1045
00:54:32,503 --> 00:54:35,004
me to show you more about the document outline. But
详细演示下 document outline。

1046
00:54:35,006 --> 00:54:38,140
watch this, so I'm gonna go down here. The spinner is just
看这里，滚到这里，有个可以直接

1047
00:54:38,142 --> 00:54:40,509
a thing you can drag out. You see it right here.
进行拖拽的指示器。就是这个。

1048
00:54:40,511 --> 00:54:42,544
Now watch what happens when I drag this out, okay, and
将它拖到界面中，

1049
00:54:42,546 --> 00:54:46,215
I try to use the blue lines to put it in the middle, drop it.
蓝色辅助线可帮助居中，就扔到这。

1050
00:54:46,217 --> 00:54:48,784
It looks like, okay, that worked, that's nice.
看起来不错，正是我们需要的。

1051
00:54:48,786 --> 00:54:50,786
I can even go here and inspect it up here.
还可以打开上面的 inspect，

1052
00:54:50,788 --> 00:54:54,123
You see, I can make a nice larger one. Maybe I'll even
这里，可以选择更大的样式。也可以

1053
00:54:54,125 --> 00:54:58,594
make it blue instead of white. Let's have it hide itself
将其改为蓝色。还可以设置

1054
00:54:58,596 --> 00:54:59,595
when it stops animating.
动画停止时，自动隐藏。

1055
00:54:59,597 --> 00:55:01,597
We can do all kinds of cool stuff here. But
这里可以设置很多属性。

1056
00:55:01,599 --> 00:55:04,400
actually something terrible has happened,
但同时引发了一个问题，

1057
00:55:04,535 --> 00:55:06,869
which is that when I dragged that thing out and
在我将控件拖出来，

1058
00:55:06,871 --> 00:55:08,037
dropped it in the middle there,
然后放置到中间时，

1059
00:55:08,039 --> 00:55:11,173
it made it a subview of the Scroll View, okay?
这个控件变成了 Scroll View 的子视图。

1060
00:55:11,175 --> 00:55:14,877
In the interface builder when you drag a view out on top of
在 interface builder 中，如果将一个控件拖到

1061
00:55:14,879 --> 00:55:16,578
another view, it makes it a subview of that.
另一个控件上，那该控件就成了另一个的子视图。

1062
00:55:16,580 --> 00:55:19,148
Now you can't really tell that here, but that's what this
直接从这里不大看的出来，

1063
00:55:19,150 --> 00:55:21,483
little guy over in the corner, the document outline,
要点击角落里的这个小按钮，打开 document outline，

1064
00:55:21,485 --> 00:55:24,353
is really great at. If you look at the document outline,
这非常棒，在 document outline 中，

1065
00:55:24,355 --> 00:55:27,189
do you see how the activity indicator is indented
能看到 activity indicator 在

1066
00:55:27,191 --> 00:55:30,893
from the Scroll View? Okay, that means it's a subview
Scroll View 中吗？这就意味着，它成为了

1067
00:55:30,895 --> 00:55:34,496
of the Scroll View. Now, if you don't want that, okay,
Scroll View 的子视图。如果你不想这样，

1068
00:55:34,498 --> 00:55:36,665
no problem. You can just drag it up above.
没问题，将它拖到上面。

1069
00:55:36,667 --> 00:55:39,568
Now, it's not a subview of the Scroll View. Now, of course,
现在，它就不再是 Scroll View 的子视图了。当然，

1070
00:55:39,570 --> 00:55:41,804
it's not in the right order right now, because I want this
这还不是正确的视图层级，因为我想要指示器

1071
00:55:41,806 --> 00:55:44,340
thing to be in front of the Scroll View. So, I'm gonna put
放在 Scroll View 前面。所以，要把

1072
00:55:44,342 --> 00:55:47,643
the Scroll View on top of it. So, now they're siblings, and
Scroll View 移到指示器上面。现在，它们就在一个层级了，并且

1073
00:55:47,645 --> 00:55:51,447
this one is in front, because remember, the subview is list,
这个再上面，记住，子视图是链表，

1074
00:55:51,449 --> 00:55:52,681
the top ones are in the back.
越在后面，层级越高。

1075
00:55:52,683 --> 00:55:54,650
The other ones go towards the front. So,
升序排列。所以，

1076
00:55:54,652 --> 00:55:58,020
now we have this thing in the front, okay? Now,
现在这个就在前面了。

1077
00:55:58,022 --> 00:56:00,522
another thing is, what if I wanna have,
还有个问题，如果我想，

1078
00:56:00,524 --> 00:56:03,359
constraints on this to keep this in the middle?
想要给该空间加约束，是它一直居中，该怎么办？

1079
00:56:03,361 --> 00:56:05,060
Well, I have to be very careful here too,
这一步同样需要仔细。

1080
00:56:05,062 --> 00:56:08,230
cuz those dashed lines. We're referring to the scroll view.
因为这里的约束，都是与 scroll view 关联的。 

1081
00:56:08,232 --> 00:56:11,033
So if I tried to do reset to suggested constraints here,
所以，先要重置默认的约束，

1082
00:56:11,035 --> 00:56:13,869
I'm gonna get constraints that constrain the activity
会发现现在 activity indicator

1083
00:56:13,871 --> 00:56:16,205
indicator to the scroll view. I don't want that.
的约束都是基于 scroll view 的，我可不想这样。

1084
00:56:16,207 --> 00:56:19,575
I want the activity indicator to be in the middle of its
我希望 activity indicator 相对其父视图

1085
00:56:19,577 --> 00:56:19,842
superview.
居中。

1086
00:56:19,844 --> 00:56:23,612
And watch this, you can do control drag in the document
看仔细了。你可以在 document outline 中，

1087
00:56:23,614 --> 00:56:26,782
outline. So I'm gonna control drag from my activity
按住 control。从 activity indicator 这里，

1088
00:56:26,784 --> 00:56:30,919
indicator to its superview in the document outline,
按住 control，拖到 document outline 中的父视图上，

1089
00:56:30,921 --> 00:56:33,255
not over here, but in the document outline.
不是这，是在 document outline 中。

1090
00:56:33,257 --> 00:56:35,758
And when I let go, I can do things like, yeah,
松开鼠标，可以看到这个，是的，

1091
00:56:35,760 --> 00:56:41,764
please center it vertically and horizontally in yourself.
请在水平与竖直方向都居中。

1092
00:56:41,766 --> 00:56:46,568
Okay? So now this thing is centered and middle. Okay?
那么，现在就居中了。

1093
00:56:46,570 --> 00:56:50,939
So, now we've got the spinner, how do we do anything with it?
至此指示器就创建好了，那应该怎么处理逻辑呢？

1094
00:56:50,941 --> 00:56:51,440
Well, we need an outlet to it.
现在需要一个它的 outlet。

1095
00:56:51,442 --> 00:56:55,511
So, I'm going to bring out my code over here, okay?
把代码显示出来，

1096
00:56:55,513 --> 00:56:56,712
Do it automatic.
自动关联文件。

1097
00:56:56,714 --> 00:56:59,681
Got our image view controller here, let's give it to this,
这是 image view controller。关掉这个，

1098
00:56:59,683 --> 00:57:02,851
give it to that, give it some room. Okay so
关掉这个，腾点空间出来。好的，


1099
00:57:02,853 --> 00:57:05,721
I'm just going to create an outlet from this little
将指示器从这拖到这，

1100
00:57:05,723 --> 00:57:10,125
spinner right here, over here. See it make sure that it's
创建 outlet。注意这里的类型

1101
00:57:10,127 --> 00:57:13,796
type is activity indicator view not something else, and
是 activity indicator，而不是别的。

1102
00:57:13,798 --> 00:57:14,730
I'm just going to call it spinner,
名字就叫 spinner 吧，

1103
00:57:14,732 --> 00:57:17,499
I like spinner as my name. And it's just an outlet,
我喜欢 spinner 这个名字，这是个 outlet，

1104
00:57:17,501 --> 00:57:20,769
it's a normal outlet just like our scroll view or anything
非常普通的 outlet，和 scroll view 或其他 outlet

1105
00:57:20,771 --> 00:57:23,272
else is an outlet. Okay just like your display was in your
没区别。就像计算器能显示一样，

1106
00:57:23,274 --> 00:57:27,643
calculator there's nothing particularly special about it.
没什么特别的。

1107
00:57:27,645 --> 00:57:31,413
So now that we have this nice spinner right here,
现在，我们拿到了指示器变量，

1108
00:57:31,415 --> 00:57:34,450
we just need to turn it on and turn it off. So where are we
只需要控制它的开始与结束。那什么时候开始呢？

1109
00:57:34,452 --> 00:57:37,352
gonna turn it on? Well, I'm gonna turn it on right before
我觉得它应该在其他线程开始

1110
00:57:37,354 --> 00:57:41,023
I start doing something on that other thread, okay. So
处理事情的时候开始。

1111
00:57:41,025 --> 00:57:44,493
right here when I dispatch onto this other thread to go
就是这里，在将处理 NSData 的 block 派发到

1112
00:57:44,495 --> 00:57:47,629
do this NSData, which is gonna block, I'm just gonna say
其他线程的时候，让

1113
00:57:47,631 --> 00:57:53,435
spinner startAnimating. And I'm gonna be even trickier and
spinner startAnimating。我准备在这里增加点难度，

1114
00:57:53,437 --> 00:57:56,972
go spinner?.startAnimating just in case
改为 spinner?startAnimating，防止

1115
00:57:56,974 --> 00:58:00,776
I'm fetching my image like as a result of prepare for
在 prepare for segue 的时候

1116
00:58:00,778 --> 00:58:03,846
segue, okay, because there my outlets aren't set.
调用该方法获取图片，而这个时候，outlet 还未创建。

1117
00:58:03,848 --> 00:58:05,747
So even if my app spinner's not set,
这样的话，在 spinner 还没创建时，

1118
00:58:05,749 --> 00:58:09,751
I'll just do nothing. Now where do I wanna turn it off?
没有任何响应就行。那应该在何时停止呢？

1119
00:58:09,753 --> 00:58:11,954
Its actually two places that you can turn this off.
应该有两处地方需要停止。

1120
00:58:11,956 --> 00:58:16,892
One good place might be down here when your image gets set.
一处是在图片加载完成后。

1121
00:58:16,894 --> 00:58:18,994
Okay? Cuz if someone sets your image,
在图片加载完成后，

1122
00:58:18,996 --> 00:58:23,198
then you don't need to be spending anymore.
spinner 就没必要显示了。

1123
00:58:23,367 --> 00:58:25,434
By definition, you're showing the image.
理论上，这里图片都已经展示了。

1124
00:58:25,436 --> 00:58:29,004
So, it will make no sense to be spinning such a good place.
所以，spinner 已经完成使命了。

1125
00:58:29,006 --> 00:58:31,106
Got to be a little careful though here because,
另外一个地方需要特别小心，

1126
00:58:31,108 --> 00:58:34,109
what happens when we get in here, okay?
这里会出现什么情况呢，

1127
00:58:34,111 --> 00:58:36,378
And you get to the URL here, and
这里是获得 URL，

1128
00:58:36,380 --> 00:58:38,647
the image data wasn't able to be found, so
如果 URL 未找到图片数据，

1129
00:58:38,649 --> 00:58:41,583
you never call set image, so it's never going to stop.
图片就无法创建，那指示器就一直没停止。

1130
00:58:41,585 --> 00:58:45,387
So you probably want to put in else spinner stop animating
所以这里也需要加上 spinner 停止的代码。

1131
00:58:45,389 --> 00:58:48,490
here as well. Okay so this is gonna stop the spinner in
所以， spinner 就会在

1132
00:58:48,492 --> 00:58:52,094
the case where it went off to the Internet to get something,
无网络，或者未找到数据的情况下，

1133
00:58:52,096 --> 00:58:55,030
and it couldn't find it. Okay, eh,
停止。哦，

1134
00:58:55,032 --> 00:59:00,969
little tricky. Okay, so let's see how that works.
小失误。好，运行看看效果。

1135
00:59:06,644 --> 00:59:08,810
Alright, here we go, let's try Earth, there it is,
跑起来了，打开 Earth，对，没错，

1136
00:59:08,812 --> 00:59:11,513
it's spinning, and we can go back, let's try Cassini, it's
有指示器了，点击返回，打开 Cassini，也有

1137
00:59:11,515 --> 00:59:15,484
spinning. Now when Cassini appears it stops spinning, and
指示器。在 Cassini 加载完后，指示器停止，

1138
00:59:15,486 --> 00:59:19,354
so it hides because we had, we set this switch over here
并且自动消失，因为我们之前字 inspect 中，

1139
00:59:19,356 --> 00:59:23,158
on this one we inspected it called hides when stopped,
将它设置为停止就自动隐藏，

1140
00:59:23,160 --> 00:59:28,196
right. And so since it hides when stopped, it's not here
没问题。所以，在停止后，指示器

1141
00:59:28,198 --> 00:59:32,734
anymore okay. [INAUDIBLE] Saturn,
就不见了。[听不清] Saturn，

1142
00:59:32,736 --> 00:59:38,974
spins okay then we can rotate. Big image, taking a long time.
旋转屏幕。是个大图，需要更长的时间。

1143
00:59:38,976 --> 00:59:43,312
There it is, okay? So see how we turn this into an app, it's
完成，没问题。这就是在 app 中的运用，

1144
00:59:43,314 --> 00:59:45,948
really responsive and really nice and it's being as fast as
非常友好，非常漂亮，说多快有多快。

1145
00:59:45,950 --> 00:59:47,983
it can. It's getting those images as fast as it can,
图片现在说多快有多快，

1146
00:59:47,985 --> 00:59:51,153
but from the user standpoint, it's very responsive.
从用户的角度来说，也非常友好。

1147
00:59:51,155 --> 00:59:53,288
You really wanna go with that way.
大家以后也应该这样做。

1148
00:59:53,290 --> 00:59:57,326
Okay, so now I'm gonna show two unrelated to this, okay?
接下来，我将提到两个不相关的东西。

1149
00:59:57,328 --> 01:00:01,697
But did you've asked about in Piazza. One is notice that
大家对 Piazza 有以为吗。在运行的时候，

1150
01:00:01,699 --> 01:00:07,235
when we run this, let's run again, watch what happens.
重新运行下，看看出了什么问题。

1151
01:00:07,972 --> 01:00:14,009
When we run, we get an empty image view controller
在运行起来时，image view controller 是空的，

1152
01:00:14,011 --> 01:00:17,012
which really doesn't make any sense. What we'd
而这不应该出现才对。我们想要的是，

1153
01:00:17,014 --> 01:00:19,848
really want it to, when we first run and this is empty,
在第一次运行的时候，这是空的，

1154
01:00:19,850 --> 01:00:23,251
we want it to come up showing this view controller. So
而我们想要的是展示这个 controller。

1155
01:00:23,253 --> 01:00:24,152
this is like with your calculator,
这和之前的计算器项目类似，

1156
01:00:24,154 --> 01:00:25,921
you don't want it to come up showing empty graph.
我们不想展示空的界面。

1157
01:00:25,923 --> 01:00:28,857
You want it to come up showing the calculator because
空界面什么用都没有，应该展示

1158
01:00:28,859 --> 01:00:29,391
the empty graph is useless,
计算器界面才对。

1159
01:00:29,393 --> 01:00:32,394
it just forces them to do that back thing right here for
这个还必须要手动返回，而且

1160
01:00:32,396 --> 01:00:35,931
no good reason. Okay, so how do we do that, okay this is
还不知道为什么要这样。那么，该怎么处理呢，

1161
01:00:35,933 --> 01:00:38,367
another case where we need to use delegation.
这是另个需要用到 delegation 的原因。

1162
01:00:38,369 --> 01:00:43,105
In this case it's the split view delegate. Okay, split
这里要用到的是 split view delegate。split

1163
01:00:43,107 --> 01:00:45,407
view controller's delegate. So what does this code look like?
view controller 的 delegate。那代码该怎么写呢？

1164
01:00:45,409 --> 01:00:48,143
I'm gonna put this in Cassini, view controller right here.
我准备把代码放在 Cassiini view controller 的这个地方。

1165
01:00:48,145 --> 01:00:51,113
The first thing I need to do is I need to make the Cassini
首先，我准备，我准备将 Cassini view controller 设为

1166
01:00:51,115 --> 01:00:55,150
view controller be its own split view's delegate.
split view 的 delegate。

1167
01:00:55,152 --> 01:00:57,052
In other words, it needs to be the delegate of
也就是说，它需要成为

1168
01:00:57,054 --> 01:00:57,319
the split view it's in.
split view 的代理。

1169
01:00:57,321 --> 01:01:01,156
So I'm gonna do this in viewDidLoad. Okay sometimes
我准备在 viewDidLoad 里面处理。

1170
01:01:01,158 --> 01:01:03,525
viewDidLoad is not quite early enough to do things for
在 viewDidLoad 中，获取 split view 才

1171
01:01:03,527 --> 01:01:07,462
split views. We might have to do it in a wait for even. But
不算太早。别的方法可能还要判断时机，而

1172
01:01:07,464 --> 01:01:10,165
this will work in viewDidLoad. And I'm just going to set
viewDidLoad 就不用。我准备在这里设置

1173
01:01:10,167 --> 01:01:14,136
my split view controllers remember MVC knows the split
split view controller，每个 MVC 能拿到 split

1174
01:01:14,138 --> 01:01:16,872
view controller its in. Or the navigation controller its in,
view controller 变量。Navigation controller 也可以，

1175
01:01:16,874 --> 01:01:18,106
or the tab bar controller its in. So
tab bar controller 也行。

1176
01:01:18,108 --> 01:01:22,611
SplitViewController says what it is, might be nil, okay? But
而 splitViewController 也可能为空，

1177
01:01:22,613 --> 01:01:25,514
if it's not I'm gonna set its delegate to be myself.
如果不为空，则设置 self 为 delegate。

1178
01:01:25,516 --> 01:01:29,284
Of course as soon as I do this I'm getting an error because
当然，这样处理会出现错误，

1179
01:01:29,286 --> 01:01:32,954
I didn't say that I was a UI SplitViewController delegate.
因为 self 还未遵循 UISplitViewControllerDelegate。

1180
01:01:32,956 --> 01:01:33,822
So I need to go up here and
滚动到顶部，

1181
01:01:33,824 --> 01:01:37,793
say that I'm a UI SplitViewController delegate.
声明 self 遵循 UISplitViewControllerDelegate。

1182
01:01:39,096 --> 01:01:43,365
All right that satisfies that error. All is good. Now which
好的，错误解决了。没问题，那么，

1183
01:01:43,367 --> 01:01:46,668
split view controller method am I going to implement?
应该实现 split view controller 的哪个方法呢？

1184
01:01:46,670 --> 01:01:49,538
Okay hold on your chairs for this one, okay
抓紧椅子，别被吓到了。

1185
01:01:49,540 --> 01:01:52,007
by the way again on the split view controller delegate so
因为已经遵循 split view controller delegate，所以

1186
01:01:52,009 --> 01:01:54,142
I can just start typing split view and you can see it
键入 split view 就可以索引出方法，看吧，

1187
01:01:54,144 --> 01:01:56,678
shows me all the split view controller delegate methods.
这些，全都是 split view controller delegate 的方法。

1188
01:01:56,680 --> 01:01:59,781
There's quite a few. Okay about a dozen of them.
有很多方法，大概十多个。

1189
01:01:59,783 --> 01:02:02,918
And the one I want is the one that controls
而我需要的那个，

1190
01:02:02,920 --> 01:02:07,222
the collapsing of the detail on top of the master.
是可以控制 detail 压缩的方法。

1191
01:02:07,224 --> 01:02:10,058
Because I don't want it to collapse that detail on top of
因为在 detail 没有数据时，不需要将

1192
01:02:10,060 --> 01:02:13,595
the master if the detail is empty, okay?
detail 显示出来。

1193
01:02:13,597 --> 01:02:14,429
If it doesn't have an image in there,
如果没有图片，

1194
01:02:14,431 --> 01:02:17,666
I don't want it to do that. So this thing that controls that
就不需要显示。这个方法叫做，

1195
01:02:17,668 --> 01:02:22,738
it's called, called secondary view controller,
叫做 secondary view controller，

1196
01:02:22,740 --> 01:02:26,708
on to primary view controller. Okay, called
on to primary view controller。

1197
01:02:26,710 --> 01:02:29,511
secondary view controller, on to primary view controller.
secondary view controller，on to primary view controller。

1198
01:02:29,513 --> 01:02:32,748
Now, notice it returns a Bool, this Bool
注意，返回值为 Bool，如果

1199
01:02:32,750 --> 01:02:35,650
you return true if you took care of this.
返回 true，就是自行处理。

1200
01:02:35,652 --> 01:02:40,589
Return false if you want the system to do the collapse.
如果返回 false，表示交由系统处理。

1201
01:02:40,591 --> 01:02:43,492
Okay, so this is a way where the delegate can do this


1202
01:02:43,494 --> 01:02:44,726
collapse if it wants, or not, and

1203
01:02:44,728 --> 01:02:47,629
it just lets the split view know whether it did it or not.

1204
01:02:47,631 --> 01:02:50,232
So that's what the bool is, let it know when it did it.

1205
01:02:50,234 --> 01:02:53,568
So, this is actually quite simple right here.

1206
01:02:53,570 --> 01:02:56,738
We just want to get the image view controller,

1207
01:02:56,740 --> 01:03:00,675
okay? Well first of all let's make sure that the primary

1208
01:03:00,677 --> 01:03:05,881
view controller, content view controller, is ourself.

1209
01:03:05,883 --> 01:03:08,083
Now it should be, because we're setting ourselves

1210
01:03:08,085 --> 01:03:09,718
as our own split view delegate, so we should be

1211
01:03:09,720 --> 01:03:13,188
the primary view controllers, the masters content Okay?

1212
01:03:13,190 --> 01:03:16,658
So we showed you that, that should not be a problem. But

1213
01:03:16,660 --> 01:03:20,896
now I'm gonna say, on top of that, if I can let ivc =

1214
01:03:20,898 --> 01:03:24,633
the secondaryViewController, that's the detail.

1215
01:03:24,635 --> 01:03:30,238
It contentViewController as an ImageViewController. Okay? So,

1216
01:03:30,240 --> 01:03:36,011
if have a ImageViewController as my detail, and

1217
01:03:36,013 --> 01:03:39,281
where, everyone know about where, right? You did your

1218
01:03:39,283 --> 01:03:41,783
reading assignments, you know about where. Where is

1219
01:03:41,785 --> 01:03:44,686
an additional clause that you can add onto an if, okay?

1220
01:03:44,688 --> 01:03:47,856
So I'm gonna say where the image view controllers

1221
01:03:47,858 --> 01:03:52,828
image URL is nil. So if I have an image view controller as

1222
01:03:52,830 --> 01:03:58,166
my detail and it's, image url is nil, then it's empty.

1223
01:03:58,168 --> 01:03:59,968
There's nothing in there. There's no Saturn or

1224
01:03:59,970 --> 01:04:03,638
anything else. So in this case I'm going to return true,

1225
01:04:03,640 --> 01:04:05,874
which is me telling the system, yeah,

1226
01:04:05,876 --> 01:04:08,710
I took care of that. Okay, I put that detail, I collapsed

1227
01:04:08,712 --> 01:04:11,079
that detail on top of the master, don't worry about it.

1228
01:04:11,081 --> 01:04:13,982
Now I didn't, didn't actually do anything, that's good,

1229
01:04:13,984 --> 01:04:16,017
cuz that's what I want. I don't want that

1230
01:04:16,019 --> 01:04:18,753
detail to be collapsed on top of the master if the thing is

1231
01:04:18,755 --> 01:04:22,357
nil. All right, so I just kind of lied to the system and told

1232
01:04:22,359 --> 01:04:26,328
them I handled it when in fact I didn't. Okay, otherwise,

1233
01:04:26,330 --> 01:04:29,431
we're just gonna let the system do whatever it does,

1234
01:04:29,433 --> 01:04:33,902
okay. Return false, we did not handle this so you handle it.

1235
01:04:33,904 --> 01:04:41,543
Okay, so let's see if that works. Okay, so here it is,

1236
01:04:41,545 --> 01:04:46,615
look at that. It came up, didn't show me a blank thing,

1237
01:04:46,617 --> 01:04:51,319
so it worked. Now let's click on one of these. Woop, okay,

1238
01:04:51,321 --> 01:04:51,486
it worked. So

1239
01:04:51,488 --> 01:04:54,789
it collapsed the secondary on top of the primary when I

1240
01:04:54,791 --> 01:04:58,026
wanted it too, okay? But if it came up nil,

1241
01:04:58,028 --> 01:05:01,229
then it didn't show it. Everyone understand that? I

1242
01:05:01,231 --> 01:05:03,899
know it seems a little, a lot of long words in here [LAUGH]

1243
01:05:03,901 --> 01:05:06,501
like primary view controller, secondary view controller, but

1244
01:05:06,503 --> 01:05:09,871
this is just master in detail, that's all this is. And

1245
01:05:09,873 --> 01:05:12,040
we're just checking where the image URL's nil and just

1246
01:05:12,042 --> 01:05:14,809
returning that, we handled it when we really didn't handle

1247
01:05:14,811 --> 01:05:18,013
it because we don't want it handled. Okay. One other

1248
01:05:18,015 --> 01:05:24,252
thing I want to show you is reusing the detail in iPad.

1249
01:05:25,856 --> 01:05:31,326
Look at iPad. And we have the master detail right here.

1250
01:05:31,328 --> 01:05:35,363
Every time we click on this thing, it's creating a new MVC

1251
01:05:35,365 --> 01:05:39,334
here. Okay? Creating a brand new MVC. And if there,

1252
01:05:39,336 --> 01:05:41,102
there's really no reason for that. Okay?

1253
01:05:41,104 --> 01:05:45,373
We could absolutely just reuse this MVC right here.

1254
01:05:45,375 --> 01:05:47,842
Okay, we don't have to create a new one every time.

1255
01:05:47,844 --> 01:05:50,979
So, how would we do that? How would we reuse this?

1256
01:05:50,981 --> 01:05:54,182
Well, if we're gonna reuse this, we can't use

1257
01:05:54,184 --> 01:05:57,385
segues because segues always create a new MVC.

1258
01:05:57,387 --> 01:05:59,254
That's what segues do, they create a new MVC.

1259
01:05:59,256 --> 01:06:02,390
So, we can't use segues, okay, to do that in that case. So,

1260
01:06:02,392 --> 01:06:06,761
lets go back to our Cassini right here. Our, storyboard.

1261
01:06:06,763 --> 01:06:11,800
And we're not going to use these segues over here. Okay,

1262
01:06:11,802 --> 01:06:14,069
see these three segues? I'm gonna get rid of them.

1263
01:06:14,071 --> 01:06:16,671
Get rid of, oops, not that. Click here,

1264
01:06:16,673 --> 01:06:16,738
get rid of that one,

1265
01:06:16,740 --> 01:06:18,940
I'm gonna get rid of that one, I'm gonna get rid of that one.

1266
01:06:18,942 --> 01:06:20,442
Cuz I cannot segue from these buttons or

1267
01:06:20,444 --> 01:06:24,446
it will constantly create a new one of these details.

1268
01:06:24,448 --> 01:06:26,781
Instead, what I'm gonna do is to use target action.

1269
01:06:26,783 --> 01:06:30,952
So I'm just gonna bring up my code here, some space,

1270
01:06:30,954 --> 01:06:34,289
all right, and I'm gonna do a target action message from

1271
01:06:34,291 --> 01:06:38,626
each of these that reuses the detail to show the image.

1272
01:06:38,628 --> 01:06:41,529
So let's do that. Let's just go Ctrl+drag here.

1273
01:06:41,531 --> 01:06:44,332
I'm gonna call this show image, that's a good name for

1274
01:06:44,334 --> 01:06:47,602
this action right here, and I'm gonna have UI button

1275
01:06:47,604 --> 01:06:50,505
be the center, cuz I'm gonna know which one to show because

1276
01:06:50,507 --> 01:06:52,640
I'm gonna look at the sender. Okay. So,

1277
01:06:52,642 --> 01:06:54,909
I got show image right here. So, let's go ahead and

1278
01:06:54,911 --> 01:06:56,978
put the code here. So, show image is a lot like,

1279
01:06:56,980 --> 01:07:00,448
looks a lot like prepare for seg, segue. We can only do

1280
01:07:00,450 --> 01:07:04,119
this if we're in a split view. Right, we can only do the show

1281
01:07:04,121 --> 01:07:07,555
image thing here, this trick, if we are in a split view,

1282
01:07:07,557 --> 01:07:11,192
sorry, let me, just so we can see what's going on here.

1283
01:07:11,194 --> 01:07:14,129
All right. Okay, we can only do a split view so

1284
01:07:14,131 --> 01:07:17,098
I'm gonna first check to see that. I'm gonna say,

1285
01:07:17,100 --> 01:07:21,836
if I can let the ivc = splitViewControllers,

1286
01:07:21,838 --> 01:07:24,773
if I have one, view Controller,

1287
01:07:24,775 --> 01:07:29,110
controller[1]. We know that's the detail, right.

1288
01:07:29,112 --> 01:07:30,478
And actually I don't wanna use sub one

1289
01:07:30,480 --> 01:07:33,248
because if for some reason my split view controller

1290
01:07:33,250 --> 01:07:36,217
doesn't have a detail, then view controllers only have one

1291
01:07:36,219 --> 01:07:39,721
thing so I'm actually gonna use ViewController.last.

1292
01:07:39,723 --> 01:07:43,258
Okay, because last returns nil if there's no such thing.

1293
01:07:43,260 --> 01:07:46,227
Okay, and then I'm gonna grab the content view controller as

1294
01:07:46,229 --> 01:07:49,264
always and I'm gonna check to see if that's an image view

1295
01:07:49,266 --> 01:07:50,765
controller. So in other words,

1296
01:07:50,767 --> 01:07:53,134
if I can get my detail as an image view controller,

1297
01:07:53,136 --> 01:07:56,271
then I'm basically gonna do this right here,

1298
01:07:56,273 --> 01:07:59,507
in here, but here I don't have to say sender as UI button

1299
01:07:59,509 --> 01:08:00,008
because the sender is

1300
01:08:00,010 --> 01:08:02,177
a UI button so I can just say sender and

1301
01:08:02,179 --> 01:08:06,614
it's never gonna be nil there. Okay? And do that. So see,

1302
01:08:06,616 --> 01:08:09,384
see what's going on here? So no segueing,

1303
01:08:09,386 --> 01:08:16,825
I'm not doing any segueing. So when I go over here, Okay,

1304
01:08:16,827 --> 01:08:20,762
and I pick something, like Cassini, or Earth, okay,

1305
01:08:20,764 --> 01:08:25,767
we'll say. It loads it up. Actually,

1306
01:08:25,769 --> 01:08:28,236
we got to do one other thing, sorry. Back here, in our

1307
01:08:28,238 --> 01:08:31,673
storyboard, let's wire up all these buttons to do that.

1308
01:08:31,675 --> 01:08:35,977
[LAUGH] Okay, we only wired up earth to do this show image so

1309
01:08:35,979 --> 01:08:39,080
let's do that. Let's go to automatic.

1310
01:08:39,583 --> 01:08:40,415
All right, so let's control,

1311
01:08:40,417 --> 01:08:42,750
so this one here and let's wire up this one here. Okay,

1312
01:08:42,752 --> 01:08:46,354
so now all three buttons are sending that same show image.

1313
01:08:46,356 --> 01:08:49,057
So now we can actually demonstrate this. So let's

1314
01:08:49,059 --> 01:08:53,094
do Cassini. Here it is showing this and once this appears, or

1315
01:08:53,096 --> 01:08:55,930
even before it appeared, I could hit Earth and

1316
01:08:55,932 --> 01:08:59,000
it just reusing this. No seugues, so there's no way I'm

1317
01:08:59,002 --> 01:09:02,837
creating a new MVC here. It's just reloading it, okay,

1318
01:09:02,839 --> 01:09:07,842
just by setting the image URL on the image there. Got it?

1319
01:09:08,178 --> 01:09:11,813
Okay. Now, what about back on iPhone, though?

1320
01:09:11,815 --> 01:09:13,815
Let's go back to iPhone.

1321
01:09:13,817 --> 01:09:18,286
Is this going to work over here? No, it's not

1322
01:09:18,288 --> 01:09:21,422
because it only does that thing if it's in split view.

1323
01:09:21,424 --> 01:09:24,759
Remember I said if split view controller, so if I hit Earth,

1324
01:09:24,761 --> 01:09:28,163
it's not working at all now, cuz it's not segueing here. So

1325
01:09:28,165 --> 01:09:31,699
really what I need to do back here in Cassini is I need to

1326
01:09:31,701 --> 01:09:35,904
say [COUGH] if I'm in a split view controller, then do this.

1327
01:09:35,906 --> 01:09:39,107
Otherwise, I basically want to segue. Okay, so

1328
01:09:39,109 --> 01:09:44,078
now I'm gonna show you how to segue from code. Okay,

1329
01:09:44,080 --> 01:09:46,147
you've only learned how to segue from,

1330
01:09:46,149 --> 01:09:46,981
by dragging in Storyboard.

1331
01:09:46,983 --> 01:09:50,018
And now I'm gonna show you how to do it in code,

1332
01:09:50,020 --> 01:09:53,788
which is you just say performSegueWithIdentifier.

1333
01:09:53,790 --> 01:09:55,490
And you give it the identifier. So

1334
01:09:55,492 --> 01:10:00,094
we'll use the Storyboard ShowImageSegue,

1335
01:10:00,096 --> 01:10:01,930
and the sender can be whatever you want,

1336
01:10:01,932 --> 01:10:05,200
I'm gonna have the sender be this sender button right here,

1337
01:10:05,202 --> 01:10:06,868
this button that's asking us to show image, so

1338
01:10:06,870 --> 01:10:09,137
it's gonna be one of those Earth things or whatever.

1339
01:10:09,139 --> 01:10:11,839
Now this, perform segue with identifier,

1340
01:10:11,841 --> 01:10:16,477
requires that such a segue exist in the storyboard. Okay,

1341
01:10:16,479 --> 01:10:17,545
and we got rid of all those segues.

1342
01:10:17,547 --> 01:10:20,915
So that's not gonna work. We need to have a storyboard with

1343
01:10:20,917 --> 01:10:24,252
this identifier, and the way you do this is, you actually

1344
01:10:24,254 --> 01:10:27,622
segue from the view controller itself. Instead of seguing

1345
01:10:27,624 --> 01:10:30,792
from one of the buttons, when you wanna segue in code,

1346
01:10:30,794 --> 01:10:32,527
you segue from the view controller itself,

1347
01:10:32,529 --> 01:10:35,930
from this little icon right here down to wherever you want

1348
01:10:35,932 --> 01:10:39,234
to segue to. So we want to segue to this, right here,

1349
01:10:39,236 --> 01:10:42,537
put these close to each other. Okay, so I'm just gonna Ctrl +

1350
01:10:42,539 --> 01:10:47,242
drag from here to here. It's gonna be, it can be show,

1351
01:10:47,244 --> 01:10:50,178
because we're never doing this in a split view controller cuz

1352
01:10:50,180 --> 01:10:52,313
split view controller we're doing the other thing. So

1353
01:10:52,315 --> 01:10:55,750
we do show. We've got this thing here now, this one

1354
01:10:55,752 --> 01:10:59,387
segue, this segue sets up the whole view controller to here.

1355
01:10:59,389 --> 01:11:03,992
We still need to set its identifier to ShowImage. Okay?

1356
01:11:03,994 --> 01:11:07,996
And now, back here in this code, when we do perform segue

1357
01:11:07,998 --> 01:11:11,399
with identifier, it's going to do that segue. And

1358
01:11:11,401 --> 01:11:13,368
we're seguing from the view controller to the other one,

1359
01:11:13,370 --> 01:11:15,470
not with the buttons anymore, from the view controller, so

1360
01:11:15,472 --> 01:11:22,977
let's see if that works now on iPhone All right, Cassini.

1361
01:11:22,979 --> 01:11:24,279
Sure enough it's working. Okay, so

1362
01:11:24,281 --> 01:11:26,481
it's doing that segue, it's back to doing the segues.

1363
01:11:26,483 --> 01:11:29,417
So this is a new MVC. Go back. This is a new MVC.

1364
01:11:29,419 --> 01:11:33,054
But it's only doing it on iPhone because if you look at

1365
01:11:33,056 --> 01:11:35,089
our code over here in the showImage,

1366
01:11:35,091 --> 01:11:38,159
if it's in a split view controller, it just reuses

1367
01:11:38,161 --> 01:11:41,863
the image view controller that's already in the split,

1368
01:11:41,865 --> 01:11:46,234
in the detail. Okay? Got all that? All right,

1369
01:11:46,236 --> 01:11:48,670
I think I have time to do the last bit of slides here,

1370
01:11:48,672 --> 01:11:54,242
oops, which is on text field, go through it pretty quickly.

1371
01:11:54,911 --> 01:11:56,878
All right, so UITextField. I haven't been able to show

1372
01:11:56,880 --> 01:11:59,714
it to you right now because it requires delegation to work.

1373
01:11:59,716 --> 01:12:01,683
Without delegation, text fields don't work. So

1374
01:12:01,685 --> 01:12:04,585
UITextField is like UILabel but it's editable.

1375
01:12:04,587 --> 01:12:08,089
Users can touch on it and then a keyboard comes up and

1376
01:12:08,091 --> 01:12:09,424
they can start typing in it.

1377
01:12:09,426 --> 01:12:11,926
UITextField is not really a very main stream

1378
01:12:11,928 --> 01:12:15,530
input mechanism on the iPhone because the keyboard is very

1379
01:12:15,532 --> 01:12:18,700
small, okay? So, you only want to use UITextField when you

1380
01:12:18,702 --> 01:12:21,836
absolutely can't get the text from the user in any other

1381
01:12:21,838 --> 01:12:23,705
way. You can't offer them a choice

1382
01:12:23,707 --> 01:12:26,708
from a list of the things, they have to actually type it

1383
01:12:26,710 --> 01:12:29,477
in, okay? So, be careful, this is not a desktop app that you

1384
01:12:29,479 --> 01:12:33,214
are building. It's a mobile app. All right so,

1385
01:12:33,216 --> 01:12:35,416
TextField is not a primary input source. Now,

1386
01:12:35,418 --> 01:12:39,354
the keyboard appears whenever a TextField becomes

1387
01:12:39,356 --> 01:12:41,989
the first responder, and you can make a TextField the first

1388
01:12:41,991 --> 01:12:44,792
responder by sending it the message, becomeFirstResponder.

1389
01:12:44,794 --> 01:12:46,761
And then it will become the first responder.

1390
01:12:46,763 --> 01:12:48,529
You can make it stop being the first responder,

1391
01:12:48,531 --> 01:12:51,299
in which case the keyboard will go away, by saying,

1392
01:12:51,301 --> 01:12:54,202
resignFirstResponder, okay?

1393
01:12:54,204 --> 01:12:54,669
So, the keyboard appears and

1394
01:12:54,671 --> 01:12:57,905
disappears purely if there's something on the screen

1395
01:12:57,907 --> 01:13:00,641
that wants to be the first responder. Okay, simple as

1396
01:13:00,643 --> 01:13:06,981
that. Now, delegation is used here primarily with the return

1397
01:13:06,983 --> 01:13:09,951
key. So, if you bring up that little software keyboard

1398
01:13:09,953 --> 01:13:11,919
in the corner, there's a button called Return.

1399
01:13:11,921 --> 01:13:15,256
And if you click return the TextField's delegate will

1400
01:13:15,258 --> 01:13:17,892
be sent this message textFieldShouldReturn. It's

1401
01:13:17,894 --> 01:13:20,762
called ShouldReturn because it returns a Bool about whether

1402
01:13:20,764 --> 01:13:23,631
it should do target/action when that return happens.

1403
01:13:23,633 --> 01:13:26,534
Because a TextField is like a button, if someone types in

1404
01:13:26,536 --> 01:13:29,904
there and hits Return, it'll do target/action, okay?

1405
01:13:29,906 --> 01:13:30,405
You can control drag and

1406
01:13:30,407 --> 01:13:32,407
it'll target/action just like a button. But

1407
01:13:32,409 --> 01:13:35,476
this text field should return, either has to return true or

1408
01:13:35,478 --> 01:13:37,278
it has to not be implemented by the delegate for

1409
01:13:37,280 --> 01:13:41,182
that to work. But one thing, so usually do implement this,

1410
01:13:41,184 --> 01:13:43,818
because one thing you wanna do in here is resign first

1411
01:13:43,820 --> 01:13:47,155
responder. A lot of times when the user hits return,

1412
01:13:47,157 --> 01:13:48,656
you do the target/action, but

1413
01:13:48,658 --> 01:13:51,259
you want the keyboard to go away. So, a lot of times

1414
01:13:51,261 --> 01:13:52,660
you'll do that here and TextField should return. So,

1415
01:13:52,662 --> 01:13:55,663
you just need to set yourself as the UITextField delegate,

1416
01:13:55,665 --> 01:13:58,466
you've got to save it to the UITextField delegate, and

1417
01:13:58,468 --> 01:14:01,369
then you implement this method and inside just say sender,

1418
01:14:01,371 --> 01:14:03,805
which is the text field that's sending this to you,

1419
01:14:03,807 --> 01:14:08,342
design first responder. You can also find out when editing

1420
01:14:08,344 --> 01:14:11,446
has ended in your TextField, meaning that the user

1421
01:14:11,448 --> 01:14:14,682
clicked on another TextField usually and you've resigned

1422
01:14:14,684 --> 01:14:17,285
first responder. Okay, any time you resign first

1423
01:14:17,287 --> 01:14:19,787
responder you'll get sent this and you can ask the TextField,

1424
01:14:19,789 --> 01:14:23,758
ok, what text is in you. Okay, so that's another interesting

1425
01:14:23,760 --> 01:14:26,360
one. And as I said, TextField's UIControl,

1426
01:14:26,362 --> 01:14:28,529
you can do target/action, just control, drag.

1427
01:14:28,531 --> 01:14:32,600
The keyboard, you configure the keyboard actually by

1428
01:14:32,602 --> 01:14:33,401
talking to the TextField.

1429
01:14:33,403 --> 01:14:37,905
There's no UI keyboard object that you talk to in iOS, okay?

1430
01:14:37,907 --> 01:14:39,407
When you wanna configure your keyboard,

1431
01:14:39,409 --> 01:14:42,343
you talk to the thing that's bringing the keyboard up.

1432
01:14:42,345 --> 01:14:43,411
In this case, the TextField. And

1433
01:14:43,413 --> 01:14:45,913
there's all kinds of methods in here you could look at.

1434
01:14:45,915 --> 01:14:48,950
This is the UITextInputTraits protocol, so

1435
01:14:48,952 --> 01:14:51,085
that's where you wanna look in the documentation, for

1436
01:14:51,087 --> 01:14:51,519
this protocol. Remember,

1437
01:14:51,521 --> 01:14:54,088
a protocol is just a bunch of methods and bars, that's all

1438
01:14:54,090 --> 01:14:57,825
these are. And these will set what kind of keyboard it is,

1439
01:14:57,827 --> 01:15:00,895
you're entering a URL? Is it a password thing,

1440
01:15:00,897 --> 01:15:04,999
where you can't see the text? All that stuff Is part of that

1441
01:15:05,001 --> 01:15:07,702
protocol, so you wanna look that up. One thing about

1442
01:15:07,704 --> 01:15:11,806
the keyboard, it comes up over your UI so it might block.

1443
01:15:11,808 --> 01:15:14,141
It might even block the TextField that you're

1444
01:15:14,143 --> 01:15:16,744
editing in, if you're not careful about how you layer UI

1445
01:15:16,746 --> 01:15:19,680
out. And we are gonna talk later into the quarter about

1446
01:15:19,682 --> 01:15:23,017
this NSNotification center. It's a way to get notified

1447
01:15:23,019 --> 01:15:25,920
when things happened and when a keyboard comes up and

1448
01:15:25,922 --> 01:15:28,789
blocks your UI, you will get notified, okay?

1449
01:15:28,791 --> 01:15:29,423
And when we talk about this,

1450
01:15:29,425 --> 01:15:32,593
you'll understand what you can do. You could move your UI

1451
01:15:32,595 --> 01:15:35,129
up from out underneath it, or maybe it's in scroll view,

1452
01:15:35,131 --> 01:15:37,265
you could scroll up or something like that, but

1453
01:15:37,267 --> 01:15:38,966
you have to be careful about this. They keyboard,

1454
01:15:38,968 --> 01:15:40,835
just boom, comes up right on top of your UI and

1455
01:15:40,837 --> 01:15:42,803
it can really block things, okay? So,

1456
01:15:42,805 --> 01:15:45,940
you'll need to eventually learn how to respond to this

1457
01:15:45,942 --> 01:15:49,443
notification. There's lots of other TextField properties

1458
01:15:49,445 --> 01:15:53,447
that are interesting here. You can actually put a little

1459
01:15:53,449 --> 01:15:55,683
button on the side. You can decide where,

1460
01:15:55,685 --> 01:15:58,920
when the user touches it, does it clear out what's in there?

1461
01:15:58,922 --> 01:16:00,855
You can have a place holder in there, so

1462
01:16:00,857 --> 01:16:02,189
that when there's nothing in the field,

1463
01:16:02,191 --> 01:16:03,457
there's a kind of a light gray text.

1464
01:16:03,459 --> 01:16:05,626
Kind of telling the user what's supposed to be there,

1465
01:16:05,628 --> 01:16:06,994
that kind of thing.

1466
01:16:06,996 --> 01:16:09,430
Anytime I show you anything in this class,

1467
01:16:09,432 --> 01:16:12,066
like UITextField or UIButton or anything, of course I'm

1468
01:16:12,068 --> 01:16:15,069
expecting you to go read the documentation, okay. Otherwise

1469
01:16:15,071 --> 01:16:17,271
you're just not gonna know how to use these things.

1470
01:16:17,273 --> 01:16:18,306
I only have a minute or

1471
01:16:18,308 --> 01:16:20,007
two in these classes, in the lectures to

1472
01:16:20,009 --> 01:16:22,610
kind of tell you these exist. If you need to be able to go,

1473
01:16:22,612 --> 01:16:24,345
use the documentation to figure them out, okay?

1474
01:16:24,347 --> 01:16:27,148
And this is a classic example figuring out how to

1475
01:16:27,150 --> 01:16:30,184
use TextField here, Okay? Yeah, they have these left and

1476
01:16:30,186 --> 01:16:33,120
right overlays are kind of fun. You control the layout

1477
01:16:33,122 --> 01:16:35,890
all this all kinds of stuff. The keyboard has

1478
01:16:35,892 --> 01:16:39,093
an interesting bar in it which is sorry the input

1479
01:16:39,095 --> 01:16:42,263
trait protocol. Called input accessory view you can

1480
01:16:42,265 --> 01:16:44,131
actually put a little view on top of your keyboard.

1481
01:16:44,133 --> 01:16:45,833
You've probably seen that in some apps. Right,

1482
01:16:45,835 --> 01:16:48,436
has kind of like a little view has custom stuff,

1483
01:16:48,438 --> 01:16:50,871
you can put your own view just by setting this bar.

1484
01:16:50,873 --> 01:16:54,308
It's kinda fun. All right, so that's it. On Friday,

1485
01:16:54,310 --> 01:16:56,377
we do have a section. It's on UI Testing,

1486
01:16:56,379 --> 01:17:00,147
which is literally being able to record the UI being

1487
01:17:00,149 --> 01:17:02,049
interacted with and then writing code that tests,

1488
01:17:02,051 --> 01:17:03,484
to make sure it's doing what it's supposed to be doing.

1489
01:17:03,486 --> 01:17:06,921
That's really cool. A feature in x code. And then next week,

1490
01:17:06,923 --> 01:17:08,823
we're going to talk about Table View and

1491
01:17:08,825 --> 01:17:09,190
Core Data, okay?

1492
01:17:09,192 --> 01:17:11,892
Table View is a way of showing big huge amounts of data.

1493
01:17:11,894 --> 01:17:15,563
And Core Data is a database to store big huge amounts of

1494
01:17:15,565 --> 01:17:17,164
data in. Assignment four.

1495
01:17:17,166 --> 01:17:18,399
Since it's a table view based assignment,

1496
01:17:18,401 --> 01:17:21,869
we'll go out at the end of the next lecture, and it'll be due

1497
01:17:21,871 --> 01:17:24,772
a week later. And there are no more reading assignments.

1498
01:17:24,774 --> 01:17:27,408
I can tell some of you haven't done your reading assignment

1499
01:17:27,410 --> 01:17:29,777
because you don't know some of the questions I'm asking.

1500
01:17:29,779 --> 01:17:30,778
Go back and read that stuff, really.

1501
01:17:30,780 --> 01:17:34,348
it's not that much stuff, you should really understand all

1502
01:17:34,350 --> 01:17:36,350
these things, like the where clause,

1503
01:17:36,352 --> 01:17:37,718
or you're going to be writing weird code.

1504
01:17:37,720 --> 01:17:40,154
Because people say, why didn't they just use where there,

1505
01:17:40,156 --> 01:17:40,588
why did they put another if?.

1506
01:17:40,590 --> 01:17:44,525
Okay? So, you don't want to be that guy, okay? Al lright,

1507
01:17:44,527 --> 01:17:47,228
I'll see you guys next week. >> For

1508
01:17:47,230 --> 01:17:47,261
more, please visit us at Stanford.edu

